<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DotNetty.Codecs.Http</name>
    </assembly>
    <members>
        <member name="T:DotNetty.Codecs.Http.Cookies.SameSite">
            <summary>
            Possible values for the SameSite attribute.
            See <a href="https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-05">changes to RFC6265bis</a>
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cookies.DefaultCookie.SameSite">
            <summary>
            Checks to see if this <see cref="T:DotNetty.Codecs.Http.Cookies.ICookie"/> can be sent along cross-site requests.
            For more information, please look
            <a href="https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-05">here</a>
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cookies.ICookie.Wrap">
            <summary>
            Returns true if the raw value of this <see cref="T:DotNetty.Codecs.Http.Cookies.ICookie"/>,
            was wrapped with double quotes in original Set-Cookie header.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cookies.ICookie.IsHttpOnly">
            <summary>
             Checks to see if this Cookie can only be accessed via HTTP.
             If this returns true, the Cookie cannot be accessed through
             client side script - But only if the browser supports it.
             For more information, please look "http://www.owasp.org/index.php/HTTPOnly".
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.Cookies.ServerCookieDecoder.DecodeAll(System.String)">
            <summary>
            Decodes the specified Set-Cookie HTTP header value into a <see cref="T:DotNetty.Codecs.Http.Cookies.ICookie"/>.  Unlike <see cref="M:DotNetty.Codecs.Http.Cookies.ServerCookieDecoder.Decode(System.String)"/>, this
            includes all cookie values present, even if they have the same name.
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Cookies.ServerCookieDecoder.Decode(System.String)">
            <summary>
            Decodes the specified Set-Cookie HTTP header value into a <see cref="T:DotNetty.Codecs.Http.Cookies.ICookie"/>.
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Codecs.Http.Cors.CorsConfig">
            <summary>
            Configuration for Cross-Origin Resource Sharing (CORS).
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cors.CorsConfig.IsCorsSupportEnabled">
            <summary>
            Determines if support for CORS is enabled.
            </summary>
            <returns><c>true</c> if support for CORS is enabled, false otherwise.</returns>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cors.CorsConfig.IsAnyOriginSupported">
            <summary>
            Determines whether a wildcard origin, '*', is supported.
            </summary>
            <returns><c>true</c> if any origin is allowed.</returns>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cors.CorsConfig.Origin">
            <summary>
            Returns the allowed origin. This can either be a wildcard or an origin value.
            </summary>
            <returns>the value that will be used for the CORS response header 'Access-Control-Allow-Origin'</returns>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cors.CorsConfig.Origins">
            <summary>
            Returns the set of allowed origins.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cors.CorsConfig.IsNullOriginAllowed">
            <summary>
            Web browsers may set the 'Origin' request header to 'null' if a resource is loaded
            from the local file system.
            
            <para>If isNullOriginAllowed is true then the server will response with the wildcard for the
            the CORS response header 'Access-Control-Allow-Origin'.</para>
            </summary>
            <returns><c>true</c> if a 'null' origin should be supported.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Cors.CorsConfig.ExposedHeaders">
            <summary>
            Returns a set of headers to be exposed to calling clients.
            
            <para>During a simple CORS request only certain response headers are made available by the
            browser, for example using:</para>
            <code>
            xhr.getResponseHeader("Content-Type");
            </code>
            The headers that are available by default are:
            <ul>
            <li>Cache-Control</li>
            <li>Content-Language</li>
            <li>Content-Type</li>
            <li>Expires</li>
            <li>Last-Modified</li>
            <li>Pragma</li>
            </ul>
            <para>To expose other headers they need to be specified, which is what this method enables by
            adding the headers names to the CORS 'Access-Control-Expose-Headers' response header.</para>
            </summary>
            <returns><see cref="T:System.Collections.Generic.ISet`1"/> a list of the headers to expose.</returns>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cors.CorsConfig.IsCredentialsAllowed">
             <summary>
             Determines if cookies are supported for CORS requests.
            
             <para>By default cookies are not included in CORS requests but if isCredentialsAllowed returns
             true cookies will be added to CORS requests. Setting this value to true will set the
             CORS 'Access-Control-Allow-Credentials' response header to true.</para>
            
             <para>Please note that cookie support needs to be enabled on the client side as well.
             The client needs to opt-in to send cookies by calling:</para>
             <code>
             xhr.withCredentials = true;
             </code>
             <para>The default value for 'withCredentials' is false in which case no cookies are sent.
             Setting this to true will included cookies in cross origin requests.</para>
             </summary>
             <returns><c>true</c> if cookies are supported.</returns>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cors.CorsConfig.MaxAge">
             <summary>
             Gets the maxAge setting.
            
             <para>When making a preflight request the client has to perform two request with can be inefficient.
             This setting will set the CORS 'Access-Control-Max-Age' response header and enables the
             caching of the preflight response for the specified time. During this time no preflight
             request will be made.</para>
             </summary>
             <returns>the time in seconds that a preflight request may be cached.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Cors.CorsConfig.AllowedRequestMethods">
            <summary>
            Returns the allowed set of Request Methods. The Http methods that should be returned in the
            CORS 'Access-Control-Request-Method' response header.
            </summary>
            <returns><see cref="T:System.Collections.Generic.ISet`1"/> of <see cref="T:DotNetty.Codecs.Http.HttpMethod"/>s that represent the allowed Request Methods.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Cors.CorsConfig.AllowedRequestHeaders">
            <summary>
            Returns the allowed set of Request Headers.
            </summary>
            <remarks>
            The header names returned from this method will be used to set the CORS
            'Access-Control-Allow-Headers' response header.
            </remarks>
            <returns><see cref="T:System.Collections.Generic.ISet`1"/> of strings that represent the allowed Request Headers.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Cors.CorsConfig.PreflightResponseHeaders">
            <summary>
            Returns HTTP response headers that should be added to a CORS preflight response.
            </summary>
            <returns><see cref="T:DotNetty.Codecs.Http.HttpHeaders"/> the HTTP response headers to be added.</returns>
        </member>
        <member name="P:DotNetty.Codecs.Http.Cors.CorsConfig.IsShortCircuit">
            <summary>
            Determines whether a CORS request should be rejected if it's invalid before being
            further processing.
            </summary>
            <remarks>
            CORS headers are set after a request is processed. This may not always be desired
            and this setting will check that the Origin is valid and if it is not valid no
            further processing will take place, and an error will be returned to the calling client.
            </remarks>
            <returns><c>true</c> if a CORS request should short-circuit upon receiving an invalid Origin header.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Cors.CorsConfig.ToString">
            <inheritdoc />
        </member>
        <member name="F:DotNetty.Codecs.Http.DefaultFullHttpRequest.hash">
            <summary>
            Used to cache the value of the hash code and avoid <see cref="T:DotNetty.Common.Utilities.IllegalReferenceCountException"/>.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.DefaultFullHttpResponse.hash">
            <summary>
            Used to cache the value of the hash code and avoid <see cref="T:DotNetty.Common.Utilities.IllegalReferenceCountException"/>.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.DefaultHttpHeaders.#ctor(System.Boolean)">
            <summary>
            <c>Warning!</c> Setting <paramref name="validate"/> to <c>false</c> will mean that Netty won't
            validate &amp; protect against user-supplied header values that are malicious.
            This can leave your server implementation vulnerable to
            <a href="https://cwe.mitre.org/data/definitions/113.html">
                CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')
            </a>.
            When disabling this validation, it is the responsibility of the caller to ensure that the values supplied
            do not contain a non-url-escaped carriage return (CR) and/or line feed (LF) characters.
            </summary>
            <param name="validate">Should Netty validate Header values to ensure they aren't malicious.</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpClientUpgradeHandler">
            <summary>
            Client-side handler for handling an HTTP upgrade handshake to another protocol. When the first
            HTTP request is sent, this handler will add all appropriate headers to perform an upgrade to the
            new protocol. If the upgrade fails (i.e. response is not 101 Switching Protocols), this handler
            simply removes itself from the pipeline. If the upgrade is successful, upgrades the pipeline to
            the new protocol.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpClientUpgradeHandler.UpgradeEvent">
            <summary>
            User events that are fired to notify about upgrade status.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpClientUpgradeHandler.UpgradeEvent.UpgradeIssued">
            <summary>
            The Upgrade request was sent to the server.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpClientUpgradeHandler.UpgradeEvent.UpgradeSuccessful">
            <summary>
            The Upgrade to the new protocol was successful.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpClientUpgradeHandler.UpgradeEvent.UpgradeRejected">
            <summary>
            The Upgrade was unsuccessful due to the server not issuing
            with a 101 Switching Protocols response.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpClientUpgradeHandler.ISourceCodec">
            <summary>
            The source codec that is used in the pipeline initially.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpClientUpgradeHandler.ISourceCodec.PrepareUpgradeFrom(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Removes or disables the encoder of this codec so that the <see cref="T:DotNetty.Codecs.Http.HttpClientUpgradeHandler.IUpgradeCodec"/> can send an initial greeting
            (if any).
            </summary>
            <param name="ctx"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpClientUpgradeHandler.ISourceCodec.UpgradeFrom(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Removes this codec (i.e. all associated handlers) from the pipeline.
            </summary>
            <param name="ctx"></param>
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpClientUpgradeHandler.IUpgradeCodec">
            <summary>
            A codec that the source can be upgraded to.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.HttpClientUpgradeHandler.IUpgradeCodec.Protocol">
            <summary>
            Returns the name of the protocol supported by this codec, as indicated by the <c>'UPGRADE'</c> header.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpClientUpgradeHandler.IUpgradeCodec.SetUpgradeHeaders(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IHttpRequest)">
            <summary>
            Sets any protocol-specific headers required to the upgrade request. Returns the names of
            all headers that were added. These headers will be used to populate the CONNECTION header.
            </summary>
            <param name="ctx">the context for the current handler.</param>
            <param name="upgradeRequest"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpClientUpgradeHandler.IUpgradeCodec.UpgradeTo(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IFullHttpResponse)">
            <summary>
            Performs an HTTP protocol upgrade from the source codec. This method is responsible for
            adding all handlers required for the new protocol.
            </summary>
            <param name="ctx">the context for the current handler.</param>
            <param name="upgradeResponse">the 101 Switching Protocols response that indicates that the server
            has switched to this protocol.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpClientUpgradeHandler.#ctor(DotNetty.Codecs.Http.HttpClientUpgradeHandler.ISourceCodec,DotNetty.Codecs.Http.HttpClientUpgradeHandler.IUpgradeCodec,System.Int32)">
            <summary>Constructs the client upgrade handler.</summary>
            <param name="sourceCodec">the codec that is being used initially.</param>
            <param name="upgradeCodec">the codec that the client would like to upgrade to.</param>
            <param name="maxContentLength">the maximum length of the aggregated content.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpClientUpgradeHandler.Write(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object,DotNetty.Common.Concurrency.IPromise)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpClientUpgradeHandler.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IHttpObject,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpClientUpgradeHandler.SetUpgradeRequestHeaders(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IHttpRequest)">
            <summary>
            Adds all upgrade request headers necessary for an upgrade to the supported protocols.
            </summary>
            <param name="ctx"></param>
            <param name="request"></param>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.HorizontalSpace">
            <summary>Horizontal space</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.HorizontalTab">
            <summary>Horizontal tab</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.CarriageReturn">
            <summary>Carriage return</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.EqualsSign">
            <summary>Equals '='</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.LineFeed">
            <summary>Line feed character</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Colon">
            <summary>Colon ':'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Semicolon">
            <summary>Semicolon ';'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Comma">
            <summary>Comma ','</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.DoubleQuote">
            <summary>Double quote '"'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Quote">
            <summary>'\''</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Space">
            <summary>' '</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.StartComment">
            <summary>'('</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.EndComment">
            <summary>')'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.BackSlash">
            <summary>'\\'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.ForwardSlash">
            <summary>'/'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.At">
            <summary>'@'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.EndAngleBracket">
            <summary>'>'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.StartAngleBracket">
            <summary>小于</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.StartSquareBracket">
            <summary>'['</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.EndSquareBracket">
            <summary>']'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Dot">
            <summary>'.'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.QuestionMark">
            <summary>'?'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.ExclamationMark">
            <summary>'!'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Star">
            <summary>'*'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.PlusSign">
            <summary>'+'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.MinusSign">
            <summary>'-'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Underline">
            <summary>'_'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Percent">
            <summary>'%'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Ampersand">
            <summary>'&amp;'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.NumberSign">
            <summary>'#'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Zero">
            <summary>'0'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.Nine">
            <summary>'9'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.HorizontalTabChar">
            <summary>Horizontal tab</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.CarriageReturnChar">
            <summary>Carriage return</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.EqualsSignChar">
            <summary>Equals '='</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.LineFeedChar">
            <summary>Line feed character</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.ColonChar">
            <summary>Colon ':'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.SemicolonChar">
            <summary>Semicolon ';'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.CommaChar">
            <summary>Comma ','</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.DoubleQuoteChar">
            <summary>Double quote '"'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.QuoteChar">
            <summary>'\''</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.SpaceChar">
            <summary>' '</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.StartCommentChar">
            <summary>'('</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.EndCommentChar">
            <summary>')'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.BackSlashChar">
            <summary>'\\'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.ForwardSlashChar">
            <summary>'/'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.AtChar">
            <summary>'@'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.EndAngleBracketChar">
            <summary>'>'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.StartAngleBracketChar">
            <summary>小于</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.StartSquareBracketChar">
            <summary>'['</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.EndSquareBracketChar">
            <summary>']'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.DotChar">
            <summary>'.'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.QuestionMarkChar">
            <summary>'?'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.ExclamationMarkChar">
            <summary>'!'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.StarChar">
            <summary>'*'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.PlusSignChar">
            <summary>'+'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.MinusSignChar">
            <summary>'-'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.UnderlineChar">
            <summary>'_'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.PercentChar">
            <summary>'%'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.AmpersandChar">
            <summary>'&amp;'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.NumberSignChar">
            <summary>'#'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.ZeroChar">
            <summary>'0'</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpConstants.NineChar">
            <summary>'9'</summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpContentDecoder">
            <summary>
            Decodes the content of the received <see cref="T:DotNetty.Codecs.Http.IHttpRequest"/> and <see cref="T:DotNetty.Codecs.Http.IHttpContent"/>.
            The original content is replaced with the new content decoded by the
            <see cref="T:DotNetty.Transport.Channels.Embedded.EmbeddedChannel"/>, which is created by <see cref="M:DotNetty.Codecs.Http.HttpContentDecoder.NewContentDecoder(DotNetty.Common.Utilities.ICharSequence)"/>.
            Once decoding is finished, the value of the <tt>'Content-Encoding'</tt>
            header is set to the target content encoding, as returned by <see cref="M:DotNetty.Codecs.Http.HttpContentDecoder.GetTargetContentEncoding(DotNetty.Common.Utilities.ICharSequence)"/>.
            Also, the <tt>'Content-Length'</tt> header is updated to the length of the
            decoded content.  If the content encoding of the original is not supported
            by the decoder, <see cref="M:DotNetty.Codecs.Http.HttpContentDecoder.NewContentDecoder(DotNetty.Common.Utilities.ICharSequence)"/> should return <code>null</code>
            so that no decoding occurs (i.e. pass-through).
            <para>
            Please note that this is an abstract class.  You have to extend this class
            and implement <see cref="M:DotNetty.Codecs.Http.HttpContentDecoder.NewContentDecoder(DotNetty.Common.Utilities.ICharSequence)"/> properly to make this class
            functional.  For example, refer to the source code of <see cref="T:DotNetty.Codecs.Http.HttpContentDecompressor"/>.
            </para>
            This handler must be placed after <see cref="T:DotNetty.Codecs.Http.HttpObjectDecoder"/> in the pipeline
            so that this handler can intercept HTTP requests after <see cref="T:DotNetty.Codecs.Http.HttpObjectDecoder"/>
            converts <see cref="T:DotNetty.Buffers.IByteBuffer"/>s into HTTP requests.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpContentEncoder.AcceptOutboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpContentEncoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IHttpRequest,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpContentEncoder.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IHttpObject,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpHeaderNames">
            
             Standard HTTP header names.
             
             These are all defined as lowercase to support HTTP/2 requirements while also not
             violating HTTP/1.x requirements.New header names should always be lowercase.
             
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpHeaders.Copy">
            <summary>
            Deep copy of the headers.
            </summary>
            <returns>A deep copy of this.</returns>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpMethod.Options">
            <summary>
            The OPTIONS method represents a request for information about the communication options
            available on the request/response chain identified by the Request-URI. This method allows
            the client to determine the options and/or requirements associated with a resource, or the
            capabilities of a server, without implying a resource action or initiating a resource retrieval.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpMethod.Get">
            <summary>
            The GET method means retrieve whatever information (in the form of an entity) is identified
            by the Request-URI.  If the Request-URI refers to a data-producing process, it is the
            produced data which shall be returned as the entity in the response and not the source text
            of the process, unless that text happens to be the output of the process.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpMethod.Head">
            <summary>
            The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpMethod.Post">
            <summary>
            The POST method is used to request that the origin server accept the entity enclosed in the
            request as a new subordinate of the resource identified by the Request-URI in the
            Request-Line.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpMethod.Put">
            <summary>
            The PUT method requests that the enclosed entity be stored under the supplied Request-URI.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpMethod.Patch">
            <summary>
            The PATCH method requests that a set of changes described in the
            request entity be applied to the resource identified by the Request-URI.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpMethod.Delete">
            <summary>
            The DELETE method requests that the origin server delete the resource identified by the Request-URI.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpMethod.Trace">
            <summary>
            The TRACE method is used to invoke a remote, application-layer loop- back of the request message.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpMethod.Connect">
            <summary>
            This specification reserves the method name CONNECT for use with a proxy that can dynamically
            switch to being a tunnel
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpMethod.#ctor(System.String)">
            <summary>
            Creates a new HTTP method with the specified name.  You will not need to
            create a new method unless you are implementing a protocol derived from
            HTTP, such as
            http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol and
            http://en.wikipedia.org/wiki/Internet_Content_Adaptation_Protocol
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpObjectAggregator">
            <summary>
            A <see cref="T:DotNetty.Transport.Channels.IChannelHandler"/> that aggregates an <see cref="T:DotNetty.Codecs.Http.IHttpMessage"/>
            and its following <see cref="T:DotNetty.Codecs.Http.IHttpContent"/>s into a single <see cref="T:DotNetty.Codecs.Http.IFullHttpRequest"/>
            or <see cref="T:DotNetty.Codecs.Http.IFullHttpResponse"/> (depending on if it used to handle requests or responses)
            with no following <see cref="T:DotNetty.Codecs.Http.IHttpContent"/>s.  It is useful when you don't want to take
            care of HTTP messages whose transfer encoding is 'chunked'.  Insert this
            handler after <see cref="T:DotNetty.Codecs.Http.HttpResponseDecoder"/> in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> if being used to handle
            responses, or after <see cref="T:DotNetty.Codecs.Http.HttpRequestDecoder"/> and <see cref="T:DotNetty.Codecs.Http.HttpResponseEncoder"/> in the
            <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> if being used to handle requests.
            <blockquote>
             <para>
             <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/> p = ...;
             ...
             p.addLast("decoder", <b>new <see cref="T:DotNetty.Codecs.Http.HttpRequestDecoder"/>()</b>);
             p.addLast("encoder", <b>new <see cref="T:DotNetty.Codecs.Http.HttpResponseEncoder"/>()</b>);
             p.addLast("aggregator", <b>new <see cref="T:DotNetty.Codecs.Http.HttpObjectAggregator"/>(1048576)</b>);
             ...
             p.addLast("handler", new HttpRequestHandler());
             </para>
            </blockquote>
            <p>
            For convenience, consider putting a <see cref="T:DotNetty.Codecs.Http.HttpServerCodec"/> before the <see cref="T:DotNetty.Codecs.Http.HttpObjectAggregator"/>
            as it functions as both a <see cref="T:DotNetty.Codecs.Http.HttpRequestDecoder"/> and a <see cref="T:DotNetty.Codecs.Http.HttpResponseEncoder"/>.
            </p>
            Be aware that <see cref="T:DotNetty.Codecs.Http.HttpObjectAggregator"/> may end up sending a <see cref="T:DotNetty.Codecs.Http.IHttpResponse"/>:
            <table>
              <tbody>
                <tr>
                  <th>Response Status</th>
                  <th>Condition When Sent</th>
                </tr>
                <tr>
                  <td>100 Continue</td>
                  <td>A '100-continue' expectation is received and the 'content-length' doesn't exceed maxContentLength</td>
                </tr>
                <tr>
                  <td>417 Expectation Failed</td>
                  <td>A '100-continue' expectation is received and the 'content-length' exceeds maxContentLength</td>
                </tr>
                <tr>
                  <td>413 Request Entity Too Large</td>
                  <td>Either the 'content-length' or the bytes received so far exceed maxContentLength</td>
                </tr>
              </tbody>
            </table>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.#ctor(System.Int32)">
            <summary>Creates a new instance.</summary>
            <param name="maxContentLength">the maximum length of the aggregated content in bytes.
            If the length of the aggregated content exceeds this value,
            <see cref="M:DotNetty.Codecs.Http.HttpObjectAggregator.HandleOversizedMessage(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IHttpMessage)"/> will be called.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.#ctor(System.Int32,System.Boolean)">
            <summary>Creates a new instance.</summary>
            <param name="maxContentLength">the maximum length of the aggregated content in bytes.
            If the length of the aggregated content exceeds this value,
            <see cref="M:DotNetty.Codecs.Http.HttpObjectAggregator.HandleOversizedMessage(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IHttpMessage)"/> will be called.</param>
            <param name="closeOnExpectationFailed">If a 100-continue response is detected but the content length is too large
            then <c>true</c> means close the connection. otherwise the connection will remain open and data will be
            consumed and discarded until the next request is received.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.IsStartMessage(DotNetty.Codecs.Http.IHttpObject)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.IsContentMessage(DotNetty.Codecs.Http.IHttpObject)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.IsLastContentMessage(DotNetty.Codecs.Http.IHttpContent)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.IsAggregated(DotNetty.Codecs.Http.IHttpObject)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.IsContentLengthInvalid(DotNetty.Codecs.Http.IHttpMessage,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.NewContinueResponse(DotNetty.Codecs.Http.IHttpMessage,System.Int32,DotNetty.Transport.Channels.IChannelPipeline)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.CloseAfterContinueResponse(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.IgnoreContentAfterContinueResponse(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.BeginAggregation(DotNetty.Codecs.Http.IHttpMessage,DotNetty.Buffers.IByteBuffer)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.Aggregate(DotNetty.Codecs.Http.IFullHttpMessage,DotNetty.Codecs.Http.IHttpContent)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.FinishAggregation(DotNetty.Codecs.Http.IFullHttpMessage)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectAggregator.HandleOversizedMessage(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IHttpMessage)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpObjectDecoder">
             <summary>
             Decodes <see cref="T:DotNetty.Buffers.IByteBuffer"/>s into <see cref="T:DotNetty.Codecs.Http.IHttpMessage"/>s and
             <see cref="T:DotNetty.Codecs.Http.IHttpContent"/>s.
            
             <h3>Parameters that prevents excessive memory consumption</h3>
             <table border="1">
             <tr>
             <th>Name</th><th>Meaning</th>
             </tr>
             <tr>
             <td>{@code maxInitialLineLength}</td>
             <td>The maximum length of the initial line
                 (e.g. {@code "GET / HTTP/1.0"} or {@code "HTTP/1.0 200 OK"})
                 If the length of the initial line exceeds this value, a
                 <see cref="T:DotNetty.Codecs.TooLongFrameException"/> will be raised.</td>
             </tr>
             <tr>
             <td>{@code maxHeaderSize}</td>
             <td>The maximum length of all headers.  If the sum of the length of each
                 header exceeds this value, a <see cref="T:DotNetty.Codecs.TooLongFrameException"/> will be raised.</td>
             </tr>
             <tr>
             <td><see cref="F:DotNetty.Codecs.Http.HttpObjectDecoder._maxChunkSize"/></td>
             <td>The maximum length of the content or each chunk.  If the content length
                 (or the length of each chunk) exceeds this value, the content or chunk
                 will be split into multiple <see cref="T:DotNetty.Codecs.Http.IHttpContent"/>s whose length is
                 <see cref="F:DotNetty.Codecs.Http.HttpObjectDecoder._maxChunkSize"/> at maximum.</td>
             </tr>
             </table>
            
             <h3>Chunked Content</h3>
            
             If the content of an HTTP message is greater than <see cref="F:DotNetty.Codecs.Http.HttpObjectDecoder._maxChunkSize"/> or
             the transfer encoding of the HTTP message is 'chunked', this decoder
             generates one <see cref="T:DotNetty.Codecs.Http.IHttpMessage"/> instance and its following
             <see cref="T:DotNetty.Codecs.Http.IHttpContent"/>s per single HTTP message to avoid excessive memory
             consumption. For example, the following HTTP message:
             <pre>
             GET / HTTP/1.1
             Transfer-Encoding: chunked
            
             1a
             abcdefghijklmnopqrstuvwxyz
             10
             1234567890abcdef
             0
             Content-MD5: ...
             <i>[blank line]</i>
             </pre>
             triggers <see cref="T:DotNetty.Codecs.Http.HttpRequestDecoder"/> to generate 3 objects:
             <ol>
             <li>An <see cref="T:DotNetty.Codecs.Http.IHttpRequest"/>,</li>
             <li>The first <see cref="T:DotNetty.Codecs.Http.IHttpContent"/> whose content is {@code 'abcdefghijklmnopqrstuvwxyz'},</li>
             <li>The second <see cref="T:DotNetty.Codecs.Http.ILastHttpContent"/> whose content is {@code '1234567890abcdef'}, which marks
             the end of the content.</li>
             </ol>
            
             If you prefer not to handle <see cref="T:DotNetty.Codecs.Http.IHttpContent"/>s by yourself for your
             convenience, insert <see cref="T:DotNetty.Codecs.Http.HttpObjectAggregator"/> after this decoder in the
             <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.  However, please note that your server might not
             be as memory efficient as without the aggregator.
            
             <h3>Extensibility</h3>
            
             Please note that this decoder is designed to be extended to implement
             a protocol derived from HTTP, such as
             <a href="http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol">RTSP</a> and
             <a href="http://en.wikipedia.org/wiki/Internet_Content_Adaptation_Protocol">ICAP</a>.
             To implement the decoder of such a derived protocol, extend this class and
             implement all abstract methods properly.
             </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectDecoder.#ctor">
            <summary>
            Creates a new instance with the default
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectDecoder.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a new instance with the specified parameters.
            </summary>
            <param name="maxInitialLineLength"></param>
            <param name="maxHeaderSize"></param>
            <param name="maxChunkSize"></param>
            <param name="chunkedSupported"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectDecoder.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Creates a new instance with the specified parameters.
            </summary>
            <param name="maxInitialLineLength"></param>
            <param name="maxHeaderSize"></param>
            <param name="maxChunkSize"></param>
            <param name="chunkedSupported"></param>
            <param name="validateHeaders"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectDecoder.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Creates a new instance with the specified parameters.
            </summary>
            <param name="maxInitialLineLength"></param>
            <param name="maxHeaderSize"></param>
            <param name="maxChunkSize"></param>
            <param name="chunkedSupported"></param>
            <param name="validateHeaders"></param>
            <param name="initialBufferSize"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectDecoder.IsSwitchingToNonHttp1Protocol(DotNetty.Codecs.Http.IHttpResponse)">
            <summary>
            Returns true if the server switched to a different protocol than HTTP/1.0 or HTTP/1.1, e.g. HTTP/2 or Websocket.
            Returns false if the upgrade happened in a different layer, e.g. upgrade from HTTP/1.1 to HTTP/1.1 over TLS.
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectDecoder.Reset">
            <summary>
            Resets the state of the decoder so that it is ready to decode a new message.
            This method is useful for handling a rejected request with {@code Expect: 100-continue} header.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectDecoder.HandleTransferEncodingChunkedWithContentLength(DotNetty.Codecs.Http.IHttpMessage)">
            <summary>
            Invoked when a message with both a "Transfer-Encoding: chunked" and a "Content-Length" header field is detected.
            The default behavior is to <i>remove</i> the Content-Length field, but this method could be overridden
            to change the behavior (to, e.g., throw an exception and produce an invalid message).
            
            <para>See: https://tools.ietf.org/html/rfc7230#section-3.3.3 </para>
            <para>
                If a message is received with both a Transfer-Encoding and a
                Content-Length header field, the Transfer-Encoding overrides the
                Content-Length.  Such a message might indicate an attempt to
                perform request smuggling (Section 9.5) or response splitting
                (Section 9.4) and ought to be handled as an error.  A sender MUST
                remove the received Content-Length field prior to forwarding such
                a message downstream.
            </para>
            Also see:
            https://github.com/apache/tomcat/blob/b693d7c1981fa7f51e58bc8c8e72e3fe80b7b773/
            java/org/apache/coyote/http11/Http11Processor.java#L747-L755
            https://github.com/nginx/nginx/blob/0ad4393e30c119d250415cb769e3d8bc8dce5186/
            src/http/ngx_http_request.c#L1946-L1953
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpObjectEncoder`1.AcceptOutboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpRequestEncoder.AcceptOutboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpRequestEncoder.EncodeInitialLine(DotNetty.Buffers.IByteBuffer,DotNetty.Codecs.Http.IHttpRequest)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseEncoder.AcceptOutboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseEncoder.EncodeInitialLine(DotNetty.Buffers.IByteBuffer,DotNetty.Codecs.Http.IHttpResponse)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseEncoder.SanitizeHeadersBeforeEncode(DotNetty.Codecs.Http.IHttpResponse,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseEncoder.IsContentAlwaysEmpty(DotNetty.Codecs.Http.IHttpResponse)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpResponseStatus">
            <summary>
            The response code and its description of HTTP or its derived protocols, such as
            RTSP (http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol) and 
            ICAP (http://en.wikipedia.org/wiki/Internet_Content_Adaptation_Protocol) 
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.Continue">
            <summary>100 Continue</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.SwitchingProtocols">
            <summary>101 Switching Protocols</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.Processing">
            <summary>102 Processing (WebDAV, RFC2518)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.OK">
            <summary>200 OK</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.Created">
            <summary>201 Created</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.Accepted">
            <summary>202 Accepted</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.NonAuthoritativeInformation">
            <summary>203 Non-Authoritative Information (since HTTP/1.1)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.NoContent">
            <summary>204 No Content</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.ResetContent">
            <summary>205 Reset Content</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.PartialContent">
            <summary>206 Partial Content</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.MultiStatus">
            <summary>207 Multi-Status (WebDAV, RFC2518)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.MultipleChoices">
            <summary>300 Multiple Choices</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.MovedPermanently">
            <summary>301 Moved Permanently</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.Found">
            <summary>302 Found</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.SeeOther">
            <summary>303 See Other (since HTTP/1.1)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.NotModified">
            <summary>304 Not Modified</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.UseProxy">
            <summary>305 Use Proxy (since HTTP/1.1)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.TemporaryRedirect">
            <summary>307 Temporary Redirect (since HTTP/1.1)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.PermanentRedirect">
            <summary>308 Permanent Redirect (RFC7538)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.BadRequest">
            <summary>400 Bad Request</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.Unauthorized">
            <summary>401 Unauthorized</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.PaymentRequired">
            <summary>402 Payment Required</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.Forbidden">
            <summary>403 Forbidden</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.NotFound">
            <summary>404 Not Found</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.MethodNotAllowed">
            <summary>405 Method Not Allowed</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.NotAcceptable">
            <summary>406 Not Acceptable</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.ProxyAuthenticationRequired">
            <summary>407 Proxy Authentication Required</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.RequestTimeout">
            <summary>408 Request Timeout</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.Conflict">
            <summary>409 Conflict</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.Gone">
            <summary>410 Gone</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.LengthRequired">
            <summary>411 Length Required</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.PreconditionFailed">
            <summary>412 Precondition Failed</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.RequestEntityTooLarge">
            <summary>413 Request Entity Too Large</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.RequestUriTooLong">
            <summary>414 Request-URI Too Long</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.UnsupportedMediaType">
            <summary>415 Unsupported Media Type</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.RequestedRangeNotSatisfiable">
            <summary>416 Requested Range Not Satisfiable</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.ExpectationFailed">
            <summary>417 Expectation Failed</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.MisdirectedRequest">
            <summary>421 Misdirected Request
            <para><a href="https://tools.ietf.org/html/rfc7540#section-9.1.2">421 (Misdirected Request) Status Code</a></para>
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.UnprocessableEntity">
            <summary>422 Unprocessable Entity (WebDAV, RFC4918)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.Locked">
            <summary>423 Locked (WebDAV, RFC4918)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.FailedDependency">
            <summary>424 Failed Dependency (WebDAV, RFC4918)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.UnorderedCollection">
            <summary>425 Unordered Collection (WebDAV, RFC3648)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.UpgradeRequired">
            <summary>426 Upgrade Required (RFC2817)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.PreconditionRequired">
            <summary>428 Precondition Required (RFC6585)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.TooManyRequests">
            <summary>429 Too Many Requests (RFC6585)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.RequestHeaderFieldsTooLarge">
            <summary>431 Request Header Fields Too Large (RFC6585)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.InternalServerError">
            <summary>500 Internal Server Error</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.NotImplemented">
            <summary>501 Not Implemented</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.BadGateway">
            <summary>502 Bad Gateway</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.ServiceUnavailable">
            <summary>503 Service Unavailable</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.GatewayTimeout">
            <summary>504 Gateway Timeout</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.HttpVersionNotSupported">
            <summary>505 HTTP Version Not Supported</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.VariantAlsoNegotiates">
            <summary>506 Variant Also Negotiates (RFC2295)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.InsufficientStorage">
            <summary>507 Insufficient Storage (WebDAV, RFC4918)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.NotExtended">
            <summary>510 Not Extended (RFC2774)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpResponseStatus.NetworkAuthenticationRequired">
            <summary>511 Network Authentication Required (RFC6585)</summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.ValueOf(System.Int32)">
            <summary>
            Returns the <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/> represented by the specified code.
            If the specified code is a standard HTTP getStatus code, a cached instance
            will be returned.  Otherwise, a new instance will be returned.
            </summary>
            <param name="code">The response code value</param>
            <returns>the <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/> represented by the specified <paramref name="code"/>.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.ValueOf(System.Int32,DotNetty.Common.Utilities.AsciiString)">
            <summary>
            Returns the <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/> represented by the specified <paramref name="code"/> and <paramref name="reasonPhrase"/>.
            If the specified code is a standard HTTP status <paramref name="code"/> and <paramref name="reasonPhrase"/>, a cached instance
            will be returned. Otherwise, a new instance will be returned.
            </summary>
            <param name="code">The response code value.</param>
            <param name="reasonPhrase">The response code reason phrase.</param>
            <returns>the <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/> represented by the specified <paramref name="code"/> and <paramref name="reasonPhrase"/>.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.ParseLine(DotNetty.Common.Utilities.ICharSequence)">
            <summary>
            Parses the specified HTTP status line into a <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/>. The expected formats of the line are:
            <para><see cref="P:DotNetty.Codecs.Http.HttpResponseStatus.Code"/> (e.g. 200)</para>
            <para><see cref="P:DotNetty.Codecs.Http.HttpResponseStatus.Code"/> <see cref="P:DotNetty.Codecs.Http.HttpResponseStatus.ReasonPhrase"/> (e.g. 404 Not Found)</para>
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.ParseLine(System.String)">
            <summary>
            Parses the specified HTTP status line into a <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/>. The expected formats of the line are:
            <para><see cref="P:DotNetty.Codecs.Http.HttpResponseStatus.Code"/> (e.g. 200)</para>
            <para><see cref="P:DotNetty.Codecs.Http.HttpResponseStatus.Code"/> <see cref="P:DotNetty.Codecs.Http.HttpResponseStatus.ReasonPhrase"/> (e.g. 404 Not Found)</para>
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.ParseLine(DotNetty.Common.Utilities.AsciiString)">
            <summary>
            Parses the specified HTTP status line into a <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/>. The expected formats of the line are:
            <para><see cref="P:DotNetty.Codecs.Http.HttpResponseStatus.Code"/> (e.g. 200)</para>
            <para><see cref="P:DotNetty.Codecs.Http.HttpResponseStatus.Code"/> <see cref="P:DotNetty.Codecs.Http.HttpResponseStatus.ReasonPhrase"/> (e.g. 404 Not Found)</para>
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.#ctor(System.Int32)">
            <summary>
            Creates a new instance with the specified <paramref name="code"/> and the auto-generated default reason phrase.
            </summary>
            <param name="code"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.#ctor(System.Int32,DotNetty.Common.Utilities.AsciiString)">
            <summary>
            Creates a new instance with the specified <paramref name="code"/> and its <paramref name="reasonPhrase"/>.
            </summary>
            <param name="code"></param>
            <param name="reasonPhrase"></param>
        </member>
        <member name="P:DotNetty.Codecs.Http.HttpResponseStatus.Code">
            <summary>
            Returns the code of this <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.HttpResponseStatus.CodeAsText">
            <summary>
            Returns the status code as <see cref="T:DotNetty.Common.Utilities.AsciiString"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.HttpResponseStatus.ReasonPhrase">
            <summary>
            Returns the reason phrase of this <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.HttpResponseStatus.CodeClass">
            <summary>
            Returns the class of this <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.Equals(DotNetty.Codecs.Http.HttpResponseStatus)">
            <summary>
            Equality of <see cref="T:DotNetty.Codecs.Http.HttpResponseStatus"/> only depends on <see cref="P:DotNetty.Codecs.Http.HttpResponseStatus.Code"/>.
            The reason phrase is not considered for equality.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpResponseStatus.ToString">
            <inheritdoc />
        </member>
        <member name="F:DotNetty.Codecs.Http.HttpServerCodec.queue">
            <summary>
            A queue that is used for correlating a request and a response.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerCodec.#ctor">
            <summary>
            Creates a new instance with the default decoder options
            ({@code maxInitialLineLength (4096}}, {@code maxHeaderSize (8192)}, and
            {@code maxChunkSize (8192)}).
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerCodec.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new instance with the specified decoder options.
            </summary>
            <param name="maxInitialLineLength"></param>
            <param name="maxHeaderSize"></param>
            <param name="maxChunkSize"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerCodec.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a new instance with the specified decoder options.
            </summary>
            <param name="maxInitialLineLength"></param>
            <param name="maxHeaderSize"></param>
            <param name="maxChunkSize"></param>
            <param name="validateHeaders"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerCodec.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Creates a new instance with the specified decoder options.
            </summary>
            <param name="maxInitialLineLength"></param>
            <param name="maxHeaderSize"></param>
            <param name="maxChunkSize"></param>
            <param name="validateHeaders"></param>
            <param name="initialBufferSize"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerCodec.UpgradeFrom(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Upgrades to another protocol from HTTP. Removes the <see cref="T:DotNetty.Codecs.Http.HttpRequestDecoder"/> and
            <see cref="T:DotNetty.Codecs.Http.HttpResponseEncoder"/> from the pipeline.
            </summary>
            <param name="ctx"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerKeepAliveHandler.IsSelfDefinedMessageLength(DotNetty.Codecs.Http.IHttpResponse)">
            <summary>
            Keep-alive only works if the client can detect when the message has ended without relying on the connection being
            closed.
            https://tools.ietf.org/html/rfc7230#section-6.3
            https://tools.ietf.org/html/rfc7230#section-3.3.2
            https://tools.ietf.org/html/rfc7230#section-3.3.3
            </summary>
            <param name="response">The HttpResponse to check</param>
            <returns>true if the response has a self defined message length.</returns>
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpServerUpgradeHandler.ISourceCodec">
            <summary>
            The source codec that is used in the pipeline initially.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.ISourceCodec.UpgradeFrom(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <summary>
            Removes this codec (i.e. all associated handlers) from the pipeline.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodec">
            <summary>
            A codec that the source can be upgraded to.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodec.RequiredUpgradeHeaders">
            <summary>
            Gets all protocol-specific headers required by this protocol for a successful upgrade.
            Any supplied header will be required to appear in the <see cref="F:DotNetty.Codecs.Http.HttpHeaderNames.Connection"/> header as well.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodec.PrepareUpgradeResponse(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IFullHttpRequest,DotNetty.Codecs.Http.HttpHeaders)">
            <summary>
            Prepares the <paramref name="upgradeHeaders"/> for a protocol update based upon the contents of <paramref name="upgradeRequest"/>.
            This method returns a boolean value to proceed or abort the upgrade in progress. If <c>false</c> is
            returned, the upgrade is aborted and the <paramref name="upgradeRequest"/> will be passed through the inbound pipeline
            as if no upgrade was performed. If <c>true</c> is returned, the upgrade will proceed to the next
            step which invokes <see cref="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodec.UpgradeTo(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IFullHttpRequest)"/>. When returning <c>true</c>, you can add headers to
            the <paramref name="upgradeHeaders"/> so that they are added to the 101 Switching protocols response.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodec.UpgradeTo(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IFullHttpRequest)">
             <summary>
             Performs an HTTP protocol upgrade from the source codec. This method is responsible for
             adding all handlers required for the new protocol.
            
             ctx the context for the current handler.
             upgradeRequest the request that triggered the upgrade to this protocol.
             </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodecFactory">
            <summary>
             Creates a new <see cref="T:DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodec"/> for the requested protocol name.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodecFactory.NewUpgradeCodec(DotNetty.Common.Utilities.ICharSequence)">
            <summary>
             Invoked by <see cref="T:DotNetty.Codecs.Http.HttpServerUpgradeHandler"/> for all the requested protocol names in the order of
             the client preference.The first non-<c>null</c> <see cref="T:DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodec"/> returned by this method
             will be selected.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.HttpServerUpgradeHandler.UpgradeEvent">
            <summary>
            User event that is fired to notify about the completion of an HTTP upgrade
            to another protocol. Contains the original upgrade request so that the response
            (if required) can be sent using the new protocol.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.HttpServerUpgradeHandler.UpgradeEvent.Protocol">
            <summary>
            The protocol that the channel has been upgraded to.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.HttpServerUpgradeHandler.UpgradeEvent.UpgradeRequest">
            <summary>
            Gets the request that triggered the protocol upgrade.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.#ctor(DotNetty.Codecs.Http.HttpServerUpgradeHandler.ISourceCodec,DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodecFactory)">
            <summary>
            Constructs the upgrader with the supported codecs.
            <para>
            The handler instantiated by this constructor will reject an upgrade request with non-empty content.
            It should not be a concern because an upgrade request is most likely a GET request.
            If you have a client that sends a non-GET upgrade request, please consider using
            <see cref="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.#ctor(DotNetty.Codecs.Http.HttpServerUpgradeHandler.ISourceCodec,DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodecFactory,System.Int32)"/> to specify the maximum
            length of the content of an upgrade request.
            </para>
            </summary>
            <param name="sourceCodec">the codec that is being used initially</param>
            <param name="upgradeCodecFactory">the factory that creates a new upgrade codec
            for one of the requested upgrade protocols</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.#ctor(DotNetty.Codecs.Http.HttpServerUpgradeHandler.ISourceCodec,DotNetty.Codecs.Http.HttpServerUpgradeHandler.IUpgradeCodecFactory,System.Int32)">
            <summary>
            Constructs the upgrader with the supported codecs.
            </summary>
            <param name="sourceCodec">the codec that is being used initially</param>
            <param name="upgradeCodecFactory">the factory that creates a new upgrade codec
            for one of the requested upgrade protocols</param>
            <param name="maxContentLength">the maximum length of the content of an upgrade request</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.IsUpgradeRequest(DotNetty.Codecs.Http.IHttpObject)">
            <summary>
            Determines whether or not the message is an HTTP upgrade request.
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.Upgrade(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.IFullHttpRequest)">
            <summary>
            Attempts to upgrade to the protocol(s) identified by the <see cref="F:DotNetty.Codecs.Http.HttpHeaderNames.Upgrade"/> header (if provided
            in the request).
            </summary>
            <param name="ctx">the context for this handler.</param>
            <param name="request">the HTTP request.</param>
            <returns><c>true</c> if the upgrade occurred, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.CreateUpgradeResponse(DotNetty.Common.Utilities.ICharSequence)">
            <summary>
            Creates the 101 Switching Protocols response message.
            </summary>
            <param name="upgradeProtocol"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.SplitHeader(DotNetty.Common.Utilities.ICharSequence)">
            <summary>
            Splits a comma-separated header value. The returned set is case-insensitive and contains each
            part with whitespace removed.
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.HttpServerUpgradeHandler.SplitHeader(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Splits a comma-separated header value. The returned set is case-insensitive and contains each
            part with whitespace removed.
            </summary>
            <param name="header"></param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Codecs.Http.IHttpMessage">
            <summary>
            An interface that defines an HTTP message, providing common properties for
            <see cref="T:DotNetty.Codecs.Http.IHttpRequest"/> and <see cref="T:DotNetty.Codecs.Http.IHttpResponse"/>.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.IHttpMessage.ProtocolVersion">
            <summary>
            Returns the protocol version of this <see cref="T:DotNetty.Codecs.Http.IHttpMessage"/>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.IHttpMessage.SetProtocolVersion(DotNetty.Codecs.Http.HttpVersion)">
            <summary>
            Set the protocol version of this <see cref="T:DotNetty.Codecs.Http.IHttpMessage"/>
            </summary>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="P:DotNetty.Codecs.Http.IHttpMessage.Headers">
            <summary>
            Returns the headers of this message.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.Internal.Strings">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.Internal.Strings.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.Internal.Strings.Culture">
            <summary>
              使用此强类型资源类，为所有资源查找
              重写当前线程的 CurrentUICulture 属性。
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.ExceptionArgument">
            <summary>The convention for this enum is using the argument name as the enum name</summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.ExceptionResource">
            <summary>The convention for this enum is using the resource name as the enum name</summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.Multipart.AbstractHttpData">
            <summary>
            Abstract HttpData implementation
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.Multipart.AbstractMemoryHttpData">
            <summary>
            Abstract Memory HttpData implementation
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.AbstractMemoryHttpData.GetByteBuffer">
            <summary>
            Utility to go from a In Memory FileUpload
            to a Disk (or another implementation) FileUpload
            </summary>
            <returns>the attached ByteBuf containing the actual bytes</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.DefaultHttpDataFactory.SetBaseDir(System.String)">
            <summary>
            Override global <see cref="P:DotNetty.Codecs.Http.Multipart.DiskAttribute.BaseDirectory"/> and <see cref="P:DotNetty.Codecs.Http.Multipart.DiskFileUpload.BaseDirectory"/> values.
            </summary>
            <param name="baseDir">directory path where to store disk attributes and file uploads.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.DefaultHttpDataFactory.SetDeleteOnExit(System.Boolean)">
            <summary>
            Override global <see cref="F:DotNetty.Codecs.Http.Multipart.DiskAttribute.DeleteOnExitTemporaryFile"/> and
            <see cref="F:DotNetty.Codecs.Http.Multipart.DiskFileUpload.DeleteOnExitTemporaryFile"/> values.
            </summary>
            <param name="deleteOnExit"><c>true</c> if temporary files should be deleted with the JVM, false otherwise.</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.Multipart.HttpPostMultipartRequestDecoder">
            <summary>
            This decoder will decode Body and can handle POST BODY.
            You <c>MUST</c> call <see cref="M:DotNetty.Codecs.Http.Multipart.HttpPostMultipartRequestDecoder.Destroy"/> after completion to release all resources.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder">
             <summary>
             This encoder will help to encode Request for a FORM as POST.
            
             <para>According to RFC 7231, POST, PUT and OPTIONS allow to have a body.
             This encoder will support widely all methods except TRACE since the RFC notes
             for GET, DELETE, HEAD and CONNECT: (replaces XXX by one of these methods)</para>
             <para>"A payload within a XXX request message has no defined semantics;
             sending a payload body on a XXX request might cause some existing
             implementations to reject the request."</para>
             <para>On the contrary, for TRACE method, RFC says:</para>
             <para>"A client MUST NOT send a message body in a TRACE request."</para>
             </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.EncoderMode">
            <summary>
            Different modes to use to encode form data.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.EncoderMode.RFC1738">
            <summary>
            Legacy mode which should work for most. It is known to not work with OAUTH. For OAUTH use
            <see cref="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.EncoderMode.RFC3986"/>. The W3C form recommendations this for submitting post form data.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.EncoderMode.RFC3986">
            <summary>
            Mode which is more new and is used for OAUTH
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.EncoderMode.HTML5">
            <summary>
            The HTML5 spec disallows mixed mode in multipart/form-data
            requests. More concretely this means that more files submitted
            under the same name will not be encoded using mixed mode, but
            will be treated as distinct fields.
            Reference: http://www.w3.org/TR/html5/forms.html#multipart-form-data
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.isChunked">
            <summary>Chunked false by default</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.bodyListDatas">
            <summary>InterfaceHttpData for Body (without encoding)</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.MultipartHttpDatas">
            <summary>The final Multipart List of InterfaceHttpData including encoding</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.isMultipart">
            <summary>Does this request is a Multipart request</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.MultipartDataBoundary">
            <summary>If multipart, this is the boundary for the global multipart</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.MultipartMixedBoundary">
            <summary>If multipart, there could be internal multiparts (mixed) to the global multipart. Only one level is allowed.</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.headerFinalized">
            <summary>To check if the header has been finalized</summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.#ctor(DotNetty.Codecs.Http.IHttpRequest,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="request">the request to encode</param>
            <param name="multipart">True if the FORM is a ENCTYPE="multipart/form-data"</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.#ctor(DotNetty.Codecs.Http.Multipart.IHttpDataFactory,DotNetty.Codecs.Http.IHttpRequest,System.Boolean)">
            <summary>
            TBD
            </summary>
            <param name="factory">the factory used to create InterfaceHttpData</param>
            <param name="request">the request to encode</param>
            <param name="multipart">True if the FORM is a ENCTYPE="multipart/form-data"</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.#ctor(DotNetty.Codecs.Http.Multipart.IHttpDataFactory,DotNetty.Codecs.Http.IHttpRequest,System.Boolean,DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.EncoderMode)">
            <summary>
            TBD
            </summary>
            <param name="factory">the factory used to create InterfaceHttpData</param>
            <param name="request">the request to encode</param>
            <param name="multipart">True if the FORM is a ENCTYPE="multipart/form-data"</param>
            <param name="encoderMode">the mode for the encoder to use. See <see cref="T:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.EncoderMode"/> for the details.</param>
        </member>
        <member name="P:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.IsMultipart">
            <summary>
            True if this request is a Multipart request
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.InitDataMultipart">
            <summary>
            Init the delimiter for Global Part (Data).
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.InitMixedMultipart">
            <summary>
            Init the delimiter for Mixed Part (Mixed).
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.GetNewMultipartDelimiter">
            <summary>construct a generated delimiter</summary>
            <returns>a newly generated Delimiter (either for DATA or MIXED)</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.GetBodyListAttributes">
            <summary>
            This getMethod returns a List of all InterfaceHttpData from body part.
            </summary>
            <returns>the list of InterfaceHttpData from Body part</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.SetBodyHttpDatas(System.Collections.Generic.List{DotNetty.Codecs.Http.Multipart.IInterfaceHttpData})">
            <summary>
            Set the Body HttpDatas list
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.AddBodyAttribute(System.String,System.String)">
            <summary>
            Add a simple attribute in the body as Name=Value
            </summary>
            <param name="name">name of the parameter</param>
            <param name="value">the value of the parameter</param>
            <exception cref="T:System.ArgumentNullException">for name</exception>
            <exception cref="T:DotNetty.Codecs.Http.Multipart.ErrorDataEncoderException">if the encoding is in error or if the finalize were already done</exception>
        </member>
        <member name="M:DotNetty.Codecs.Http.Multipart.HttpPostRequestEncoder.FillByteBuffer">
            <summary>
            Returns the next ByteBuf to send as an HttpChunk and modifying currentBuffer accordingly
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.Multipart.IHttpDataFactory">
            <summary>
            Interface to enable creation of IPostHttpData objects
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.QueryStringDecoder">
             <summary>
             Splits an HTTP query string into a path string and key-value parameter pairs.
             This decoder is for one time use only.  Create a new instance for each URI:
             <para>
             <code>QueryStringDecoder decoder = new QueryStringDecoder("/hello?recipient=world&amp;x=1;y=2");</code>
             assert decoder.path().equals("/hello");
             assert decoder.parameters().get("recipient").get(0).equals("world");
             assert decoder.parameters().get("x").get(0).equals("1");
             assert decoder.parameters().get("y").get(0).equals("2");
             </para>
            
             This decoder can also decode the content of an HTTP POST request whose
             content type is <tt>application/x-www-form-urlencoded</tt>:
             <para>
             QueryStringDecoder decoder = new QueryStringDecoder("recipient=world&amp;x=1;y=2", false);
             ...
             </para>
            
             <h3>HashDOS vulnerability fix</h3>
            
             As a workaround to the <a href="https://netty.io/s/hashdos">HashDOS</a> vulnerability, the decoder
             limits the maximum number of decoded key-value parameter pairs, up to {@literal 1024} by
             default, and you can configure it when you construct the decoder by passing an additional
             integer parameter.
             </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.Utilities.QueryHelpers.AddQueryString(System.String,System.String,System.String)">
            <summary>
            Append the given query key and value to the URI.
            </summary>
            <param name="uri">The base URI.</param>
            <param name="name">The name of the query key.</param>
            <param name="value">The query value.</param>
            <returns>The combined result.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Utilities.QueryHelpers.AddQueryString(System.String,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Append the given query keys and values to the uri.
            </summary>
            <param name="uri">The base uri.</param>
            <param name="queryString">A collection of name value query pairs to append.</param>
            <returns>The combined result.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Utilities.QueryHelpers.ParseQuery(System.String)">
            <summary>
            Parse a query string into its component key and value parts.
            </summary>
            <param name="queryString">The raw query string value, with or without the leading '?'.</param>
            <returns>A collection of parsed keys and values.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.Utilities.QueryHelpers.ParseNullableQuery(System.String)">
            <summary>
            Parse a query string into its component key and value parts.
            </summary>
            <param name="queryString">The raw query string value, with or without the leading '?'.</param>
            <returns>A collection of parsed keys and values, null if there are no entries.</returns>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.BinaryWebSocketFrame">
            <summary>
            Web Socket frame containing binary data.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.BinaryWebSocketFrame.#ctor">
            <summary>
            Creates a new empty binary frame.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.BinaryWebSocketFrame.#ctor(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new binary frame with the specified binary data. The final fragment flag is set to true.
            </summary>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.BinaryWebSocketFrame.#ctor(System.Boolean,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new binary frame with the specified binary data and the final fragment flag.
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.BinaryWebSocketFrame.#ctor(System.Boolean,System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new binary frame with the specified binary data and the final fragment flag.
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="rsv">reserved bits used for protocol extensions</param>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.BinaryWebSocketFrame.Replace(DotNetty.Buffers.IByteBuffer)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame">
            <summary>
            Web Socket Frame for closing the connection.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame.#ctor">
            <summary>
            Creates a new empty close frame.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketCloseStatus)">
            <summary>
            Creates a new empty close frame with closing status code and reason text
            </summary>
            <param name="status">Status code as per <a href="http://tools.ietf.org/html/rfc6455#section-7.4">RFC 6455</a>. For
            example, <tt>1000</tt> indicates normal closure.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketCloseStatus,DotNetty.Common.Utilities.ICharSequence)">
            <summary>
            Creates a new empty close frame with closing status code and reason text
            </summary>
            <param name="status">Status code as per <a href="http://tools.ietf.org/html/rfc6455#section-7.4">RFC 6455</a>. For
            example, <tt>1000</tt> indicates normal closure.</param>
            <param name="reasonText">Reason text. Set to null if no text.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame.#ctor(System.Boolean,System.Int32)">
            <summary>
            Creates a new close frame with no losing status code and no reason text
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="rsv">reserved bits used for protocol extensions.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame.#ctor(System.Boolean,System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new close frame
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="rsv">reserved bits used for protocol extensions.</param>
            <param name="binaryData">the content of the frame. Must be 2 byte integer followed by optional UTF-8 encoded string.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame.#ctor(System.Int32,DotNetty.Common.Utilities.ICharSequence)">
            <summary>
            Creates a new empty close frame with closing status code and reason text
            </summary>
            <param name="statusCode">Integer status code as per <a href="http://tools.ietf.org/html/rfc6455#section-7.4">RFC 6455</a>. For
            example, <tt>1000</tt> indicates normal closure.</param>
            <param name="reasonText">Reason text. Set to null if no text.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame.#ctor(System.Boolean,System.Int32,System.Int32,DotNetty.Common.Utilities.ICharSequence)">
            <summary>
            Creates a new close frame with closing status code and reason text
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="rsv">reserved bits used for protocol extensions.</param>
            <param name="statusCode">Integer status code as per <a href="http://tools.ietf.org/html/rfc6455#section-7.4">RFC 6455</a>. For
            example, <tt>1000</tt> indicates normal closure.</param>
            <param name="reasonText">Reason text. Set to null if no text.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame.StatusCode">
            <summary>
                Returns the closing status code as per http://tools.ietf.org/html/rfc6455#section-7.4 RFC 6455. 
                If a status code is set, -1 is returned.
             </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame.ReasonText">
            <summary>
                 Returns the reason text as per http://tools.ietf.org/html/rfc6455#section-7.4 RFC 6455
                 If a reason text is not supplied, an empty string is returned.
             </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame">
            <summary>
            Web Socket continuation frame containing continuation text or binary data. This is used for
            fragmented messages where the contents of a messages is contained more than 1 frame.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame.#ctor">
            <summary>
            Creates a new empty continuation frame.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame.#ctor(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new continuation frame with the specified binary data. The final fragment flag is
            set to true.
            </summary>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame.#ctor(System.Boolean,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new continuation frame with the specified binary data.
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame.#ctor(System.Boolean,System.String)">
            <summary>
            Creates a new continuation frame with the specified text data
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="text">text content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame.#ctor(System.Boolean,System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new continuation frame with the specified binary data.
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="rsv">reserved bits used for protocol extensions</param>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame.#ctor(System.Boolean,System.Int32,System.String)">
            <summary>
            Creates a new continuation frame with the specified text data
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="rsv">reserved bits used for protocol extensions</param>
            <param name="text">text content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame.Text">
            <summary>
            Returns the text data in this frame.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame.FromText(System.String)">
            <summary>
            Sets the string for this frame.
            </summary>
            <param name="text">text to store.</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame.Replace(DotNetty.Buffers.IByteBuffer)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.CorruptedWebSocketFrameException">
            <summary>
            An <see cref="T:DotNetty.Codecs.DecoderException"/> which is thrown when the received <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketFrame"/> data could not be decoded by
            an inbound handler.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.AlwaysSkipWebSocketExtensionFilter">
            <summary>
            A <see cref="T:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilter"/> that always skip the evaluation of an
            any given extensions <see cref="T:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtension"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateDecoder">
            <summary>
            Deflate implementation of a payload decompressor for
            <tt>io.netty.handler.codec.http.websocketx.WebSocketFrame</tt>.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateDecoder.#ctor(System.Boolean,DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilter)">
            <summary>Constructor</summary>
            <param name="noContext">true to disable context takeover.</param>
            <param name="extensionDecoderFilter">extension decoder filter.</param>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateDecoder.ExtensionDecoderFilter">
            <summary>
            Returns the extension decoder filter.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateEncoder">
            <summary>
            Deflate implementation of a payload compressor for
            <tt>io.netty.handler.codec.http.websocketx.WebSocketFrame</tt>.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateEncoder.ExtensionEncoderFilter">
            <summary>
            Returns the extension encoder filter.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateEncoder.Rsv(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <summary>
            return the rsv bits to set in the compressed frame.
            </summary>
            <param name="msg">the current frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateEncoder.RemoveFrameTail(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <summary>
            return true if compressed payload tail needs to be removed.
            </summary>
            <param name="msg">the current frame.</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateFrameClientExtensionHandshaker">
            <summary>
            <a href="https://tools.ietf.org/id/draft-tyoshino-hybi-websocket-perframe-deflate-06.txt">perframe-deflate</a>
            handshake implementation.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateFrameClientExtensionHandshaker.#ctor(System.Boolean)">
            <summary>
            Constructor with default configuration.
            </summary>
            <param name="useWebkitExtensionName"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateFrameClientExtensionHandshaker.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructor with custom configuration.
            </summary>
            <param name="compressionLevel">Compression level between 0 and 9 (default is 6).</param>
            <param name="useWebkitExtensionName"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateFrameClientExtensionHandshaker.#ctor(System.Int32,System.Boolean,DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilterProvider)">
            <summary>
            Constructor with custom configuration.
            </summary>
            <param name="compressionLevel">Compression level between 0 and 9 (default is 6).</param>
            <param name="useWebkitExtensionName"></param>
            <param name="extensionFilterProvider">provides client extension filters for per frame deflate encoder and decoder.</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateFrameServerExtensionHandshaker">
            <summary>
            <a href="https://tools.ietf.org/id/draft-tyoshino-hybi-websocket-perframe-deflate-06.txt">perframe-deflate</a>
            handshake implementation.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateFrameServerExtensionHandshaker.#ctor">
            <summary>
            Constructor with default configuration.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateFrameServerExtensionHandshaker.#ctor(System.Int32)">
            <summary>
            Constructor with custom configuration.
            </summary>
            <param name="compressionLevel">Compression level between 0 and 9 (default is 6).</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.DeflateFrameServerExtensionHandshaker.#ctor(System.Int32,DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilterProvider)">
            <summary>
            Constructor with custom configuration.
            </summary>
            <param name="compressionLevel">Compression level between 0 and 9 (default is 6).</param>
            <param name="extensionFilterProvider">provides client extension filters for per frame deflate encoder and decoder.</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateDecoder">
            <summary>
            Per-frame implementation of deflate decompressor.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateDecoder.#ctor(System.Boolean)">
            <summary>Constructor</summary>
            <param name="noContext">true to disable context takeover.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateDecoder.#ctor(System.Boolean,DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilter)">
            <summary>Constructor</summary>
            <param name="noContext">true to disable context takeover.</param>
            <param name="extensionDecoderFilter">extension decoder filter for per frame deflate decoder.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateDecoder.AcceptInboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateDecoder.NewRsv(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateDecoder.AppendFrameTail(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateEncoder">
            <summary>
            Per-frame implementation of deflate compressor.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateEncoder.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>Constructor</summary>
            <param name="compressionLevel">compression level of the compressor.</param>
            <param name="windowSize">maximum size of the window compressor buffer.</param>
            <param name="noContext">true to disable context takeover.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateEncoder.#ctor(System.Int32,System.Int32,System.Boolean,DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilter)">
            <summary>Constructor</summary>
            <param name="compressionLevel">compression level of the compressor.</param>
            <param name="windowSize">maximum size of the window compressor buffer.</param>
            <param name="noContext">true to disable context takeover.</param>
            <param name="extensionEncoderFilter">extension encoder filter for per frame deflate encoder.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateEncoder.AcceptOutboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateEncoder.Rsv(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerFrameDeflateEncoder.RemoveFrameTail(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateClientExtensionHandshaker">
            <summary>
            <a href="http://tools.ietf.org/html/draft-ietf-hybi-permessage-compression-18">permessage-deflate</a>
            handshake implementation.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateClientExtensionHandshaker.#ctor">
            <summary>Constructor with default configuration.</summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateClientExtensionHandshaker.#ctor(System.Int32,System.Boolean,System.Int32,System.Boolean,System.Boolean)">
            <summary>Constructor with custom configuration.</summary>
            <param name="compressionLevel">Compression level between 0 and 9 (default is 6).</param>
            <param name="allowClientWindowSize">allows WebSocket server to customize the client inflater window size
            (default is false).</param>
            <param name="requestedServerWindowSize">indicates the requested sever window size to use if server inflater is customizable.</param>
            <param name="allowClientNoContext">allows WebSocket server to activate client_no_context_takeover
            (default is false).</param>
            <param name="requestedServerNoContext">indicates if client needs to activate server_no_context_takeover
            if server is compatible with (default is false).</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateClientExtensionHandshaker.#ctor(System.Int32,System.Boolean,System.Int32,System.Boolean,System.Boolean,DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilterProvider)">
            <summary>Constructor with custom configuration.</summary>
            <param name="compressionLevel">Compression level between 0 and 9 (default is 6).</param>
            <param name="allowClientWindowSize">allows WebSocket server to customize the client inflater window size
            (default is false).</param>
            <param name="requestedServerWindowSize">indicates the requested sever window size to use if server inflater is customizable.</param>
            <param name="allowClientNoContext">allows WebSocket server to activate client_no_context_takeover
            (default is false).</param>
            <param name="requestedServerNoContext">indicates if client needs to activate server_no_context_takeover
            if server is compatible with (default is false).</param>
            <param name="extensionFilterProvider">provides client extension filters for per message deflate encoder and decoder.</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateDecoder">
            <summary>
            Per-message implementation of deflate decompressor.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateDecoder.#ctor(System.Boolean)">
            <summary>Constructor</summary>
            <param name="noContext">true to disable context takeover.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateDecoder.#ctor(System.Boolean,DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilter)">
            <summary>Constructor</summary>
            <param name="noContext">true to disable context takeover.</param>
            <param name="extensionDecoderFilter">extension decoder for per message deflate decoder.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateDecoder.AcceptInboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateDecoder.NewRsv(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateDecoder.AppendFrameTail(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateDecoder.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.WebSockets.WebSocketFrame,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateEncoder">
            <summary>
            Per-message implementation of deflate compressor.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateEncoder.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>Constructor</summary>
            <param name="compressionLevel">compression level of the compressor.</param>
            <param name="windowSize">maximum size of the window compressor buffer.</param>
            <param name="noContext">true to disable context takeover.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateEncoder.#ctor(System.Int32,System.Int32,System.Boolean,DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilter)">
            <summary>Constructor</summary>
            <param name="compressionLevel">compression level of the compressor.</param>
            <param name="windowSize">maximum size of the window compressor buffer.</param>
            <param name="noContext">true to disable context takeover.</param>
            <param name="extensionEncoderFilter">extension filter for per message deflate encoder.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateEncoder.AcceptOutboundMessage(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateEncoder.Rsv(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateEncoder.RemoveFrameTail(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateEncoder.Encode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.WebSockets.WebSocketFrame,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateServerExtensionHandshaker">
            <summary>
            <a href="http://tools.ietf.org/html/draft-ietf-hybi-permessage-compression-18">permessage-deflate</a>
            handshake implementation.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateServerExtensionHandshaker.#ctor">
            <summary>Constructor with default configuration.</summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateServerExtensionHandshaker.#ctor(System.Int32,System.Boolean,System.Int32,System.Boolean,System.Boolean)">
            <summary>Constructor with custom configuration.</summary>
            <param name="compressionLevel">Compression level between 0 and 9 (default is 6).</param>
            <param name="allowServerWindowSize">allows WebSocket client to customize the server inflater window size
            (default is false).</param>
            <param name="preferredClientWindowSize">indicates the preferred client window size to use if client inflater is customizable.</param>
            <param name="allowServerNoContext">allows WebSocket client to activate server_no_context_takeover
            (default is false).</param>
            <param name="preferredClientNoContext">indicates if server prefers to activate client_no_context_takeover
            if client is compatible with (default is false).</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.Extensions.Compression.PerMessageDeflateServerExtensionHandshaker.#ctor(System.Int32,System.Boolean,System.Int32,System.Boolean,System.Boolean,DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilterProvider)">
            <summary>Constructor with custom configuration.</summary>
            <param name="compressionLevel">Compression level between 0 and 9 (default is 6).</param>
            <param name="allowServerWindowSize">allows WebSocket client to customize the server inflater window size
            (default is false).</param>
            <param name="preferredClientWindowSize">indicates the preferred client window size to use if client inflater is customizable.</param>
            <param name="allowServerNoContext">allows WebSocket client to activate server_no_context_takeover
            (default is false).</param>
            <param name="preferredClientNoContext">indicates if server prefers to activate client_no_context_takeover
            if client is compatible with (default is false).</param>
            <param name="extensionFilterProvider">provides server extension filters for per message deflate encoder and decoder.</param>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtension.Rsv">
            <summary>
            The reserved bit value to ensure that no other extension should interfere.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilter">
            <summary>
            Filter that is responsible to skip the evaluation of a certain extension
            according to standard.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilterProvider">
            <summary>
            Extension filter provider that is responsible to provide filters for a certain <see cref="T:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtension"/> extension.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilterProvider.EncoderFilter">
            <summary>
            Returns the extension filter for <see cref="T:DotNetty.Codecs.Http.WebSockets.Extensions.WebSocketExtensionEncoder"/> encoder.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilterProvider.DecoderFilter">
            <summary>
            Returns the extension filter for <see cref="T:DotNetty.Codecs.Http.WebSockets.Extensions.WebSocketExtensionDecoder"/> decoder.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.NeverSkipWebSocketExtensionFilter">
            <summary>
            A <see cref="T:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtensionFilter"/> that never skip the evaluation of an
            any given extensions <see cref="T:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtension"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.WebSocketExtensionFilterProvider">
            <summary>
            Extension filter provider that is responsible to provide filters for a certain <see cref="T:DotNetty.Codecs.Http.WebSockets.Extensions.IWebSocketExtension"/> extension.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.Extensions.WebSocketExtensionFilterProvider.EncoderFilter">
            <summary>
            Returns the extension filter for <see cref="T:DotNetty.Codecs.Http.WebSockets.Extensions.WebSocketExtensionEncoder"/> encoder.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.Extensions.WebSocketExtensionFilterProvider.DecoderFilter">
            <summary>
            Returns the extension filter for <see cref="T:DotNetty.Codecs.Http.WebSockets.Extensions.WebSocketExtensionDecoder"/> decoder.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Extensions.WebSocketServerExtensionHandler">
             <summary>
             This handler negotiates and initializes the WebSocket Extensions.
            
             It negotiates the extensions based on the client desired order,
             ensures that the successfully negotiated extensions are consistent between them,
             and initializes the channel pipeline with the extension decoder and encoder.
            
             Find a basic implementation for compression extensions at
             <tt>io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketServerCompressionHandler</tt>.
             </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.IWebSocketFrameDecoder">
            <summary>
                Marker interface which all WebSocketFrame decoders need to implement. This makes it 
                easier to access the added encoder later in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.IWebSocketFrameEncoder">
            <summary>
                Marker interface which all WebSocketFrame encoders need to implement. This makes it 
                easier to access the added encoder later in the <see cref="T:DotNetty.Transport.Channels.IChannelPipeline"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.Opcode">
            <summary>Indicates the WebSocket frame type.</summary>
            <remarks>
            The values of this enumeration are defined in <see
            href="http://tools.ietf.org/html/rfc6455#section-5.2"> Section 5.2</see> of RFC 6455.
            </remarks>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.Opcode.Cont">
            <summary>Equivalent to numeric value 0. Indicates continuation frame.</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.Opcode.Text">
            <summary>Equivalent to numeric value 1. Indicates text frame.</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.Opcode.Binary">
            <summary>Equivalent to numeric value 2. Indicates binary frame.</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.Opcode.Close">
            <summary>Equivalent to numeric value 8. Indicates connection close frame.</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.Opcode.Ping">
            <summary>Equivalent to numeric value 9. Indicates ping frame.</summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.Opcode.Pong">
            <summary>Equivalent to numeric value 10. Indicates pong frame.</summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.PingWebSocketFrame">
            <summary>
            Web Socket frame containing binary data.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.PingWebSocketFrame.#ctor(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new ping frame with the specified binary data.
            </summary>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.PingWebSocketFrame.#ctor(System.Boolean,System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new ping frame with the specified binary data.
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="rsv">reserved bits used for protocol extensions</param>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.PingWebSocketFrame.Replace(DotNetty.Buffers.IByteBuffer)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.PongWebSocketFrame">
            <summary>
            Web Socket frame containing binary data.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.PongWebSocketFrame.#ctor">
            <summary>
            Creates a new empty pong frame.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.PongWebSocketFrame.#ctor(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new pong frame with the specified binary data.
            </summary>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.PongWebSocketFrame.#ctor(System.Boolean,System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new pong frame with the specified binary data
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="rsv">reserved bits used for protocol extensions</param>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.PongWebSocketFrame.Replace(DotNetty.Buffers.IByteBuffer)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.TextWebSocketFrame">
            <summary>
            Web Socket text frame.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.TextWebSocketFrame.#ctor">
            <summary>
            Creates a new empty text frame.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.TextWebSocketFrame.#ctor(System.String)">
            <summary>
            Creates a new text frame with the specified text string. The final fragment flag is set to true.
            </summary>
            <param name="text">String to put in the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.TextWebSocketFrame.#ctor(DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new text frame with the specified binary data. The final fragment flag is set to true.
            </summary>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.TextWebSocketFrame.#ctor(System.Boolean,System.String)">
            <summary>
            Creates a new text frame with the specified text string. The final fragment flag is set to true.
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="text">String to put in the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.TextWebSocketFrame.#ctor(System.Boolean,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new text frame with the specified binary data and the final fragment flag.
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.TextWebSocketFrame.#ctor(System.Boolean,System.Int32,System.String)">
            <summary>
            Creates a new text frame with the specified text string. The final fragment flag is set to true.
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="rsv">reserved bits used for protocol extensions</param>
            <param name="text">String to put in the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.TextWebSocketFrame.#ctor(System.Boolean,System.Int32,DotNetty.Buffers.IByteBuffer)">
            <summary>
            Creates a new text frame with the specified binary data and the final fragment flag.
            </summary>
            <param name="finalFragment">flag indicating if this frame is the final fragment</param>
            <param name="rsv">reserved bits used for protocol extensions</param>
            <param name="binaryData">the content of the frame.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.TextWebSocketFrame.Text">
            <summary>
            Returns the text data in this frame.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.TextWebSocketFrame.Replace(DotNetty.Buffers.IByteBuffer)">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocket00FrameDecoder">
            <summary>
            Decodes <see cref="T:DotNetty.Buffers.IByteBuffer"/>s into <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketFrame"/>s.
            <para>For the detailed instruction on adding add Web Socket support to your HTTP server, take a look into the
            <tt>WebSocketServer</tt> example located in the {@code examples.http.websocket} package.</para>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocket00FrameDecoder.#ctor(System.Int32)">
            <summary>
            Creates a new instance of <see cref="T:DotNetty.Codecs.Http.WebSockets.IWebSocketFrameDecoder"/> with the specified <paramref name="maxFrameSize"/>. If the client
            sends a frame size larger than <paramref name="maxFrameSize"/>, the channel will be closed.
            </summary>
            <param name="maxFrameSize">the maximum frame size to decode</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocket07FrameDecoder">
            <summary>
            Decodes a web socket frame from wire protocol version 7 format. V7 is essentially the same as V8.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocket07FrameDecoder.#ctor(System.Boolean,System.Boolean,System.Int32)">
            <summary>Constructor</summary>
            <param name="expectMaskedFrames">Web socket servers must set this to true processed incoming masked payload. Client implementations
            must set this to false.</param>
            <param name="allowExtensions">Flag to allow reserved extension bits to be used or not</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload. Setting this to an appropriate value for you application
            helps check for denial of services attacks.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocket07FrameDecoder.#ctor(System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <summary>Constructor</summary>
            <param name="expectMaskedFrames">Web socket servers must set this to true processed incoming masked payload. Client implementations
            must set this to false.</param>
            <param name="allowExtensions">Flag to allow reserved extension bits to be used or not</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload. Setting this to an appropriate value for you application
            helps check for denial of services attacks.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocket07FrameDecoder.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig)">
            <summary>Constructor</summary>
            <param name="decoderConfig">Frames decoder configuration.</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocket08FrameDecoder">
            <summary>
            Decodes a web socket frame from wire protocol version 8 format. This code was forked from <a
            href="https://github.com/joewalnes/webbit">webbit</a> and modified.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocket08FrameEncoder.GatheringWriteThreshold">
            
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocket13FrameDecoder">
            <summary>
            Decodes a web socket frame from wire protocol version 13 format. V13 is essentially the same as V8.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocket13FrameDecoder.#ctor(System.Boolean,System.Boolean,System.Int32)">
            <summary>Constructor</summary>
            <param name="expectMaskedFrames">Web socket servers must set this to true processed incoming masked payload. Client implementations
            must set this to false.</param>
            <param name="allowExtensions">Flag to allow reserved extension bits to be used or not</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload. Setting this to an appropriate value for you application
            helps check for denial of services attacks.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocket13FrameDecoder.#ctor(System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <summary>Constructor</summary>
            <param name="expectMaskedFrames">Web socket servers must set this to true processed incoming masked payload. Client implementations
            must set this to false.</param>
            <param name="allowExtensions">Flag to allow reserved extension bits to be used or not</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload. Setting this to an appropriate value for you application
            helps check for denial of services attacks.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocket13FrameDecoder.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig)">
            <summary>Constructor</summary>
            <param name="decoderConfig">Frames decoder configuration.</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker">
            <summary>
            Base class for web socket client handshake implementations
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,DotNetty.Codecs.Http.HttpHeaders,System.Int32)">
            <summary>Base constructor</summary>
            <param name="uri">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Int64)">
            <summary>Base constructor</summary>
            <param name="uri">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Int64,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="uri">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified</param>
            <param name="absoluteUpgradeUrl">Use an absolute url for the Upgrade request, typically when connecting through an HTTP proxy over
            clear HTTP</param>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.Uri">
            <summary>
            Returns the URI to the web socket. e.g. "ws://myhost.com/path"
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.Version">
            <summary>
            Version of the web socket specification that is being used
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.MaxFramePayloadLength">
            <summary>
            Returns the max length for any frame's payload
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.IsHandshakeComplete">
            <summary>
            Flag to indicate if the opening handshake is complete
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.ExpectedSubprotocol">
            <summary>
            Returns the CSV of requested subprotocol(s) sent to the server as specified in the constructor
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.ActualSubprotocol">
            <summary>
            Returns the subprotocol response sent by the server. Only available after end of handshake.
            Null if no subprotocol was requested or confirmed by the server.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.ForceCloseTimeoutMillis">
            <summary>
            Gets or sets timeout to close the connection if it was not closed by the server.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.IsForceCloseComplete">
            <summary>
            Flag to indicate if the closing handshake was initiated because of timeout.
            For testing only.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.HandshakeAsync(DotNetty.Transport.Channels.IChannel)">
            <summary>Begins the opening handshake</summary>
            <param name="channel">Channel</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.NewHandshakeRequest">
            <summary>Returns a new <see cref="T:DotNetty.Codecs.Http.IFullHttpRequest"/> which will be used for the handshake.</summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.FinishHandshake(DotNetty.Transport.Channels.IChannel,DotNetty.Codecs.Http.IFullHttpResponse)">
            <summary>
            Validates and finishes the opening handshake initiated by <see cref="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.HandshakeAsync(DotNetty.Transport.Channels.IChannel)"/>.
            </summary>
            <param name="channel">Channel</param>
            <param name="response">HTTP response containing the closing handshake details</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.ProcessHandshakeAsync(DotNetty.Transport.Channels.IChannel,DotNetty.Codecs.Http.IHttpResponse)">
            <summary>
            Process the opening handshake initiated by <see cref="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.HandshakeAsync(DotNetty.Transport.Channels.IChannel)"/>.
            </summary>
            <param name="channel">Channel</param>
            <param name="response">HTTP response containing the closing handshake details</param>
            <returns> the <see cref="T:System.Threading.Tasks.Task"/> which is notified once the handshake completes.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.Verify(DotNetty.Codecs.Http.IFullHttpResponse)">
            <summary>
            Verify the <see cref="T:DotNetty.Codecs.Http.IFullHttpResponse"/> and throws a <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketHandshakeException"/> if something is wrong.
            </summary>
            <param name="response"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.NewWebSocketDecoder">
            <summary>
            Returns the decoder to use after handshake is complete.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.NewWebSocketEncoder">
            <summary>
            Returns the encoder to use after the handshake is complete.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.CloseAsync(DotNetty.Transport.Channels.IChannel,DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame)">
            <summary>
            Performs the closing handshake
            </summary>
            <param name="channel">Channel</param>
            <param name="frame">Closing Frame that was received</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker.UpgradeUrl(System.Uri)">
            <summary>
            Return the constructed raw path for the give <paramref name="wsUrl"/>.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker00">
            <summary>
            Performs client side opening and closing handshakes for web socket specification version <a
            href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-00" >draft-ietf-hybi-thewebsocketprotocol-00</a>
            <para>A very large portion of this code was taken from the Netty 3.2 HTTP example.</para>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker00.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,DotNetty.Codecs.Http.HttpHeaders,System.Int32)">
            <summary>Creates a new instance with the specified destination WebSocket location and version to initiate.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker00.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Int64)">
            <summary>Creates a new instance with the specified destination WebSocket location and version to initiate.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker00.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Int64,System.Boolean)">
            <summary>Creates a new instance with the specified destination WebSocket location and version to initiate.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified</param>
            <param name="absoluteUpgradeUrl">Use an absolute url for the Upgrade request, typically when connecting through an HTTP proxy over
            clear HTTP</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker07">
            <summary>
            Performs client side opening and closing handshakes for web socket specification version <a
            href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07" >draft-ietf-hybi-thewebsocketprotocol-10</a>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker07.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker07.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker07.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean,System.Int64)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker07.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean,System.Int64,System.Boolean)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified.</param>
            <param name="absoluteUpgradeUrl">Use an absolute url for the Upgrade request, typically when connecting through an HTTP proxy over
            clear HTTP</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker08">
            <summary>
            Performs client side opening and closing handshakes for web socket specification version <a
            href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10" >draft-ietf-hybi-thewebsocketprotocol-10</a>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker08.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker08.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker08.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean,System.Int64)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker08.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean,System.Int64,System.Boolean)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified.</param>
            <param name="absoluteUpgradeUrl">Use an absolute url for the Upgrade request, typically when connecting through an HTTP proxy over
            clear HTTP</param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker13">
            <summary>
            Performs client side opening and closing handshakes for web socket specification version <a
            href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17" >draft-ietf-hybi-thewebsocketprotocol-17</a>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker13.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker13.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker13.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean,System.Int64)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker13.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean,System.Int64,System.Boolean)">
            <summary>Creates a new instance.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified.</param>
            <param name="absoluteUpgradeUrl">Use an absolute url for the Upgrade request, typically when connecting through an HTTP proxy over
            clear HTTP</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker13.NewHandshakeRequest">
            <summary>
            Sends the opening request to the server:
            <![CDATA[
            GET /chat HTTP/1.1
            Host: server.example.com
            Upgrade: websocket
            Connection: Upgrade
            Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
            Origin: http://example.com
            Sec-WebSocket-Protocol: chat, superchat
            Sec-WebSocket-Version: 13
            ]]>
            </summary>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker13.Verify(DotNetty.Codecs.Http.IFullHttpResponse)">
            <summary>
            Process server response:
            <![CDATA[
            HTTP/1.1 101 Switching Protocols
            Upgrade: websocket
            Connection: Upgrade
            Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
            Sec-WebSocket-Protocol: chat
            ]]>
            </summary>
            <param name="response">HTTP response returned from the server for the request sent by beginOpeningHandshake00().</param>
            <exception cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketHandshakeException">if handshake response is invalid.</exception>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshakerFactory">
            <summary>
            Creates a new <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker"/> of desired protocol version.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshakerFactory.NewHandshaker(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders)">
            <summary>Creates a new handshaker.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server. Null if no sub-protocol support is required.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Custom HTTP headers to send during the handshake</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshakerFactory.NewHandshaker(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32)">
            <summary>Creates a new handshaker.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server. Null if no sub-protocol support is required.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Custom HTTP headers to send during the handshake</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshakerFactory.NewHandshaker(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean)">
            <summary>Creates a new handshaker.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server. Null if no sub-protocol support is required.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Custom HTTP headers to send during the handshake</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshakerFactory.NewHandshaker(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean,System.Int64)">
            <summary>Creates a new handshaker.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server. Null if no sub-protocol support is required.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Custom HTTP headers to send during the handshake</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshakerFactory.NewHandshaker(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean,System.Int64,System.Boolean)">
            <summary>Creates a new handshaker.</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol">Sub protocol request sent to the server. Null if no sub-protocol support is required.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="customHeaders">Custom HTTP headers to send during the handshake</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
            <param name="forceCloseTimeoutMillis">Close the connection if it was not closed by the server after timeout specified</param>
            <param name="absoluteUpgradeUrl">Use an absolute url for the Upgrade request, typically when connecting through an HTTP proxy over
            clear HTTP</param>
            <returns></returns>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig">
            <summary>
            WebSocket client configuration.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.WebSocketUri">
            <summary>
            URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Subprotocol">
            <summary>
            Sub protocol request sent to the server.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Version">
            <summary>
            Version of web socket specification to use to connect to the server
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.AllowExtensions">
            <summary>
            Allow extensions to be used in the reserved bits of the web socket frame
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.CustomHeaders">
            <summary>
            Map of custom headers to add to the client request
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.MaxFramePayloadLength">
            <summary>
            Maximum length of a frame's payload
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.PerformMasking">
            <summary>
            Whether to mask all written websocket frames.This must be set to true in order to be fully compatible
            with the websocket specifications.Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.AllowMaskMismatch">
            <summary>
            When set to true, frames which are not masked properly according to the standard will still be accepted.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.HandleCloseFrames">
            <summary>
            <c>true</c> if close frames should not be forwarded and just close the channel
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.SendCloseFrame">
            <summary>
            Close frame to send, when close frame was not send manually. Or <c>null</c> to disable proper close.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.DropPongFrames">
            <summary>
            <c>true</c> if pong frames should not be forwarded
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.HandshakeTimeoutMillis">
            <summary>
            Handshake timeout in mills, when handshake timeout, will trigger user
            event <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeTimeout"/>
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.ForceCloseTimeoutMillis">
            <summary>
            Close the connection if it was not closed by the server after timeout specified
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.AbsoluteUpgradeUrl">
            <summary>
            Use an absolute url for the Upgrade request, typically when connecting through an HTTP proxy over clear HTTP
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.WithUTF8Validator">
            <summary>
            Allows you to avoid adding of Utf8FrameValidator to the pipeline on the
            <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler"/> creation. This is useful (less overhead)
            when you use only BinaryWebSocketFrame within your web socket connection.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.WebSocketUri(System.String)">
            <summary>
            URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.WebSocketUri(System.Uri)">
            <summary>
            URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.Subprotocol(System.String)">
            <summary>
            Sub protocol request sent to the server.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.Version(DotNetty.Codecs.Http.WebSockets.WebSocketVersion)">
            <summary>
            Version of web socket specification to use to connect to the server
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.AllowExtensions(System.Boolean)">
            <summary>
            Allow extensions to be used in the reserved bits of the web socket frame
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.CustomHeaders(DotNetty.Codecs.Http.HttpHeaders)">
            <summary>
            Map of custom headers to add to the client request
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.MaxFramePayloadLength(System.Int32)">
            <summary>
            Maximum length of a frame's payload
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.PerformMasking(System.Boolean)">
            <summary>
            Whether to mask all written websocket frames.This must be set to true in order to be fully compatible
            with the websocket specifications.Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.AllowMaskMismatch(System.Boolean)">
            <summary>
            When set to true, frames which are not masked properly according to the standard will still be accepted.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.HandleCloseFrames(System.Boolean)">
            <summary>
            <c>true</c> if close frames should not be forwarded and just close the channel
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.SendCloseFrame(DotNetty.Codecs.Http.WebSockets.WebSocketCloseStatus)">
            <summary>
            Close frame to send, when close frame was not send manually. Or <c>null</c> to disable proper close.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.DropPongFrames(System.Boolean)">
            <summary>
            <c>true</c> if pong frames should not be forwarded
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.HandshakeTimeoutMillis(System.Int64)">
            <summary>
            Handshake timeout in mills, when handshake timeout, will trigger user
            event <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeTimeout"/>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.ForceCloseTimeoutMillis(System.Int64)">
            <summary>
            Close the connection if it was not closed by the server after timeout specified
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.AbsoluteUpgradeUrl(System.Boolean)">
            <summary>
            Use an absolute url for the Upgrade request, typically when connecting through an HTTP proxy over clear HTTP
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.WithUTF8Validator(System.Boolean)">
            <summary>
            Allows you to avoid adding of Utf8FrameValidator to the pipeline on the
            <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler"/> creation. This is useful (less overhead)
            when you use only BinaryWebSocketFrame within your web socket connection.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.Builder.Build">
            <summary>
            Build unmodifiable client protocol configuration.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler">
            <summary>
            This handler does all the heavy lifting for you to run a websocket client.
            <para>
            It takes care of websocket handshaking as well as processing of Ping, Pong frames. Text and Binary
            data frames are passed to the next handler in the pipeline (implemented by you) for processing.
            Also the close frame is passed to the next handler as you may want inspect it before close the connection if
            the <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig.HandleCloseFrames"/> is <c>false</c>, default is <c>true</c>.
            </para>
            <para>
            This implementation will establish the websocket connection once the connection to the remote server was complete.
            </para>
            <para>
            To know once a handshake was done you can intercept the
            <see cref="M:DotNetty.Transport.Channels.IChannelHandler.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/> and check if the event was of type
            <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeIssued"/> or <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeComplete"/>
            </para>
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.Handshaker">
            <summary>
            Returns the used handshaker
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent">
            <summary>
            Events that are fired to notify about handshake status
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeTimeout">
            <summary>
            The Handshake was timed out
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeIssued">
            <summary>
            The Handshake was started but the server did not response yet to the request
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeComplete">
            <summary>
            The Handshake was complete succesful and so the channel was upgraded to websockets
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolConfig)">
            <summary>Base constructor</summary>
            <param name="clientConfig">Client protocol configuration.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol"></param>
            <param name="allowExtensions">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Int64,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol"></param>
            <param name="allowExtensions">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="handshakeTimeoutMillis">Handshake timeout in mills, when handshake timeout, will trigger user
            event <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeTimeout"/></param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol"></param>
            <param name="allowExtensions">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="handleCloseFrames"><c>true</c> if close frames should not be forwarded and just close the channel</param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Int64,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol"></param>
            <param name="allowExtensions">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="handleCloseFrames"><c>true</c> if close frames should not be forwarded and just close the channel</param>
            <param name="handshakeTimeoutMillis">Handshake timeout in mills, when handshake timeout, will trigger user
            event <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeTimeout"/></param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol"></param>
            <param name="allowExtensions">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="handleCloseFrames"><c>true</c> if close frames should not be forwarded and just close the channel</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(System.Uri,DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.Boolean,DotNetty.Codecs.Http.HttpHeaders,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Int64,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="version">Version of web socket specification to use to connect to the server</param>
            <param name="subprotocol"></param>
            <param name="allowExtensions">Sub protocol request sent to the server.</param>
            <param name="customHeaders">Map of custom headers to add to the client request</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
            <param name="handleCloseFrames"><c>true</c> if close frames should not be forwarded and just close the channel</param>
            <param name="performMasking">Whether to mask all written websocket frames. This must be set to true in order to be fully compatible
            with the websocket specifications. Client applications that communicate with a non-standard server
            which doesn't require masking might set this to false to achieve a higher performance.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
            <param name="handshakeTimeoutMillis">Handshake timeout in mills, when handshake timeout, will trigger user
            event <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeTimeout"/></param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="handshaker">The <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker"/> which will be used to issue the handshake once the connection
            was established to the remote peer.</param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker,System.Int64,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="handshaker">The <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker"/> which will be used to issue the handshake once the connection
            was established to the remote peer.</param>
            <param name="handshakeTimeoutMillis">Handshake timeout in mills, when handshake timeout, will trigger user
            event <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeTimeout"/></param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker,System.Boolean,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="handshaker">The <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker"/> which will be used to issue the handshake once the connection
            was established to the remote peer.</param>
            <param name="handleCloseFrames"><c>true</c> if close frames should not be forwarded and just close the channel</param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker,System.Boolean,System.Int64,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="handshaker">The <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker"/> which will be used to issue the handshake once the connection
            was established to the remote peer.</param>
            <param name="handleCloseFrames"><c>true</c> if close frames should not be forwarded and just close the channel</param>
            <param name="handshakeTimeoutMillis">Handshake timeout in mills, when handshake timeout, will trigger user
            event <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeTimeout"/></param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="handshaker">The <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker"/> which will be used to issue the handshake once the connection
            was established to the remote peer.</param>
            <param name="handleCloseFrames"><c>true</c> if close frames should not be forwarded and just close the channel</param>
            <param name="dropPongFrames"><c>true</c> if pong frames should not be forwarded</param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker,System.Boolean,System.Boolean,System.Int64,System.Boolean)">
            <summary>Base constructor</summary>
            <param name="handshaker">The <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketClientHandshaker"/> which will be used to issue the handshake once the connection
            was established to the remote peer.</param>
            <param name="handleCloseFrames"><c>true</c> if close frames should not be forwarded and just close the channel</param>
            <param name="dropPongFrames"><c>true</c> if pong frames should not be forwarded</param>
            <param name="handshakeTimeoutMillis">Handshake timeout in mills, when handshake timeout, will trigger user
            event <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandler.ClientHandshakeStateEvent.HandshakeTimeout"/></param>
            <param name="enableUtf8Validator"></param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandshakeHandler.HandlerAdded(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc/>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandshakeHandler.ChannelActive(DotNetty.Transport.Channels.IChannelHandlerContext)">
            <inheritdoc/>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandshakeHandler.ChannelRead(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketClientProtocolHandshakeHandler.GetHandshakeFuture">
            <summary>
            This method is visible for testing.
            </summary>
            <returns>current handshake future</returns>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketCloseStatus">
             <summary>
             WebSocket status codes specified in RFC-6455.
             <para>
            
             RFC-6455 The WebSocket Protocol, December 2011:
             <a href="https://tools.ietf.org/html/rfc6455#section-7.4.1"
                     >https://tools.ietf.org/html/rfc6455#section-7.4.1</a>
            
             WebSocket Protocol Registries, April 2019:
             <a href="https://www.iana.org/assignments/websocket/websocket.xhtml#close-code-number"
                     >https://www.iana.org/assignments/websocket/websocket.xhtml</a>
            
             7.4.1.  Defined Status Codes
            
             Endpoints MAY use the following pre-defined status codes when sending
             a Close frame.
            
             1000
            
                1000 indicates a normal closure, meaning that the purpose for
                which the connection was established has been fulfilled.
            
             1001
            
                1001 indicates that an endpoint is "going away", such as a server
                going down or a browser having navigated away from a page.
            
             1002
            
                1002 indicates that an endpoint is terminating the connection due
                to a protocol error.
            
             1003
            
                1003 indicates that an endpoint is terminating the connection
                because it has received a type of data it cannot accept (e.g., an
                endpoint that understands only text data MAY send this if it
                receives a binary message).
            
             1004
            
                Reserved. The specific meaning might be defined in the future.
            
             1005
            
                1005 is a reserved value and MUST NOT be set as a status code in a
                Close control frame by an endpoint. It is designated for use in
                applications expecting a status code to indicate that no status
                code was actually present.
            
             1006
            
                1006 is a reserved value and MUST NOT be set as a status code in a
                Close control frame by an endpoint. It is designated for use in
                applications expecting a status code to indicate that the
                connection was closed abnormally, e.g., without sending or
                receiving a Close control frame.
            
             1007
            
                1007 indicates that an endpoint is terminating the connection
                because it has received data within a message that was not
                consistent with the type of the message (e.g., non-UTF-8 [RFC3629]
                data within a text message).
            
             1008
            
                1008 indicates that an endpoint is terminating the connection
                because it has received a message that violates its policy. This
                is a generic status code that can be returned when there is no
                other more suitable status code (e.g., 1003 or 1009) or if there
                is a need to hide specific details about the policy.
            
             1009
            
                1009 indicates that an endpoint is terminating the connection
                because it has received a message that is too big for it to
                process.
            
             1010
            
                1010 indicates that an endpoint (client) is terminating the
                connection because it has expected the server to negotiate one or
                more extension, but the server didn't return them in the response
                message of the WebSocket handshake. The list of extensions that
                are needed SHOULD appear in the /reason/ part of the Close frame.
                Note that this status code is not used by the server, because it
                can fail the WebSocket handshake instead.
            
             1011
            
                1011 indicates that a server is terminating the connection because
                it encountered an unexpected condition that prevented it from
                fulfilling the request.
            
             1012 (IANA Registry, Non RFC-6455)
            
                1012 indicates that the service is restarted. a client may reconnect,
                and if it choses to do, should reconnect using a randomized delay
                of 5 - 30 seconds.
            
             1013 (IANA Registry, Non RFC-6455)
            
                1013 indicates that the service is experiencing overload. a client
                should only connect to a different IP (when there are multiple for the
                target) or reconnect to the same IP upon user action.
            
             1014 (IANA Registry, Non RFC-6455)
            
                The server was acting as a gateway or proxy and received an invalid
                response from the upstream server. This is similar to 502 HTTP Status Code.
            
             1015
            
                1015 is a reserved value and MUST NOT be set as a status code in a
                Close control frame by an endpoint. It is designated for use in
                applications expecting a status code to indicate that the
                connection was closed due to a failure to perform a TLS handshake
                (e.g., the server certificate can't be verified).
            
            
             7.4.2. Reserved Status Code Ranges
            
             0-999
            
                Status codes in the range 0-999 are not used.
            
             1000-2999
            
                Status codes in the range 1000-2999 are reserved for definition by
                this protocol, its future revisions, and extensions specified in a
                permanent and readily available public specification.
            
             3000-3999
            
                Status codes in the range 3000-3999 are reserved for use by
                libraries, frameworks, and applications. These status codes are
                registered directly with IANA. The interpretation of these codes
                is undefined by this protocol.
            
             4000-4999
            
                Status codes in the range 4000-4999 are reserved for private use
                and thus can't be registered. Such codes can be used by prior
                agreements between WebSocket applications. The interpretation of
                these codes is undefined by this protocol.
             </para>
             <para>
             While <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketCloseStatus"/> is enum-like structure, its instances should NOT be compared by reference.
             Instead, either <see cref="M:DotNetty.Codecs.Http.WebSockets.WebSocketCloseStatus.Equals(System.Object)"/> should be used or direct comparison of <see cref="P:DotNetty.Codecs.Http.WebSockets.WebSocketCloseStatus.Code"/> value.
             </para>
             </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig">
            <summary>
            Frames decoder configuration.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.MaxFramePayloadLength">
            <summary>
            Maximum length of a frame's payload. Setting this to an appropriate value for you application
            helps check for denial of services attacks.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.ExpectMaskedFrames">
            <summary>
            Web socket servers must set this to true processed incoming masked payload. Client implementations
            must set this to false.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.AllowMaskMismatch">
            <summary>
            Allows to loosen the masking requirement on received frames. When this is set to false then also
            frames which are not masked properly according to the standard will still be accepted.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.AllowExtensions">
            <summary>
            Flag to allow reserved extension bits to be used or not
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.CloseOnProtocolViolation">
            <summary>
            Flag to send close frame immediately on any protocol violation.ion.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.WithUTF8Validator">
            <summary>
            Allows you to avoid adding of Utf8FrameValidator to the pipeline on the
            <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolHandler"/> creation. This is useful (less overhead)
            when you use only BinaryWebSocketFrame within your web socket connection.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.ToString">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.Builder.MaxFramePayloadLength(System.Int32)">
            <summary>
            Maximum length of a frame's payload. Setting this to an appropriate value for you application
            helps check for denial of services attacks.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.Builder.ExpectMaskedFrames(System.Boolean)">
            <summary>
            Web socket servers must set this to true processed incoming masked payload. Client implementations
            must set this to false.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.Builder.AllowMaskMismatch(System.Boolean)">
            <summary>
            Allows to loosen the masking requirement on received frames. When this is set to false then also
            frames which are not masked properly according to the standard will still be accepted.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.Builder.AllowExtensions(System.Boolean)">
            <summary>
            Flag to allow reserved extension bits to be used or not
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.Builder.CloseOnProtocolViolation(System.Boolean)">
            <summary>
            Flag to send close frame immediately on any protocol violation.ion.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.Builder.WithUTF8Validator(System.Boolean)">
            <summary>
            Allows you to avoid adding of Utf8FrameValidator to the pipeline on the
            <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolHandler"/> creation. This is useful (less overhead)
            when you use only BinaryWebSocketFrame within your web socket connection.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig.Builder.Build">
            <summary>
            Build unmodifiable decoder configuration.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketFrame">
            <summary>
            Base class for web socket frames.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketFrame.IsFinalFragment">
            <summary>
            Flag to indicate if this frame is the final fragment in a message. The first fragment (frame)
            may also be the final fragment.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketFrame.Rsv">
            <summary>
            RSV1, RSV2, RSV3 used for extensions
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrame.ToString">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator">
            <summary>
            Handler that aggregate fragmented <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketFrame"/>'s.
            
            Be aware if PING/PONG/CLOSE frames are send in the middle of a fragmented <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketFrame"/> they will
            just get forwarded to the next handler in the pipeline.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.#ctor(System.Int32)">
            <summary>Creates a new instance</summary>
            <param name="maxContentLength">If the size of the aggregated frame exceeds this value,
            a <see cref="T:DotNetty.Codecs.TooLongFrameException"/> is thrown.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.IsStartMessage(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.IsContentMessage(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.IsLastContentMessage(DotNetty.Codecs.Http.WebSockets.ContinuationWebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.IsAggregated(DotNetty.Codecs.Http.WebSockets.WebSocketFrame)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.IsContentLengthInvalid(DotNetty.Codecs.Http.WebSockets.WebSocketFrame,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.NewContinueResponse(DotNetty.Codecs.Http.WebSockets.WebSocketFrame,System.Int32,DotNetty.Transport.Channels.IChannelPipeline)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.CloseAfterContinueResponse(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.IgnoreContentAfterContinueResponse(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.BeginAggregation(DotNetty.Codecs.Http.WebSockets.WebSocketFrame,DotNetty.Buffers.IByteBuffer)">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketFrameAggregator.Decode(DotNetty.Transport.Channels.IChannelHandlerContext,DotNetty.Codecs.Http.WebSockets.WebSocketFrame,System.Collections.Generic.List{System.Object})">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketProtocolHandler.#ctor">
            <summary>
            Creates a new <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketProtocolHandler"/> that will <i>drop</i> <see cref="T:DotNetty.Codecs.Http.WebSockets.PongWebSocketFrame"/>s.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketProtocolHandler.#ctor(System.Boolean)">
            <summary>
            Creates a new <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketProtocolHandler"/>, given a parameter that determines whether or not to drop
            <see cref="T:DotNetty.Codecs.Http.WebSockets.PongWebSocketFrame"/>s.
            </summary>
            <param name="dropPongFrames"></param>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker">
            <summary>
            Base class for server side web socket opening and closing handshakes
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.String,System.Int32)">
            <summary>
            Constructor specifying the destination web socket location
            </summary>
            <param name="version">the protocol version</param>
            <param name="uri">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols. Null if sub protocols not supported.</param>
            <param name="maxFramePayloadLength">Maximum length of a frame's payload</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.#ctor(DotNetty.Codecs.Http.WebSockets.WebSocketVersion,System.String,System.String,DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig)">
            <summary>
            Constructor specifying the destination web socket location
            </summary>
            <param name="version">the protocol version</param>
            <param name="uri">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols. Null if sub protocols not supported.</param>
            <param name="decoderConfig">Frames decoder configuration.</param>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.Uri">
            <summary>
            Returns the URL of the web socket
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.Subprotocols">
            <summary>
            Returns the CSV of supported sub protocols
            </summary>
            <returns></returns>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.Version">
            <summary>
            Returns the version of the specification being supported
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.MaxFramePayloadLength">
            <summary>
            Gets the maximum length for any frame's payload.
            </summary>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.DecoderConfig">
            <summary>
            Gets this decoder configuration.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.HandshakeAsync(DotNetty.Transport.Channels.IChannel,DotNetty.Codecs.Http.IFullHttpRequest)">
            <summary>
            Performs the opening handshake
            When call this method you <c>MUST NOT</c> retain the <see cref="T:DotNetty.Codecs.Http.IFullHttpRequest"/> which is passed in.
            </summary>
            <param name="channel">Channel</param>
            <param name="req">HTTP Request</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.HandshakeAsync(DotNetty.Transport.Channels.IChannel,DotNetty.Codecs.Http.IFullHttpRequest,DotNetty.Codecs.Http.HttpHeaders)">
            <summary>
            Performs the opening handshake
            When call this method you <c>MUST NOT</c> retain the <see cref="T:DotNetty.Codecs.Http.IFullHttpRequest"/> which is passed in.
            </summary>
            <param name="channel">Channel</param>
            <param name="req">HTTP Request</param>
            <param name="responseHeaders">Extra headers to add to the handshake response or <code>null</code> if no extra headers should be added</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.Handshake(DotNetty.Transport.Channels.IChannel,DotNetty.Codecs.Http.IFullHttpRequest,DotNetty.Codecs.Http.HttpHeaders,DotNetty.Common.Concurrency.IPromise)">
            <summary>
            Performs the opening handshake
            When call this method you <c>MUST NOT</c> retain the <see cref="T:DotNetty.Codecs.Http.IFullHttpRequest"/> which is passed in.
            </summary>
            <param name="channel">Channel</param>
            <param name="req">HTTP Request</param>
            <param name="responseHeaders">Extra headers to add to the handshake response or <code>null</code> if no extra headers should be added</param>
            <param name="completion">the <see cref="T:DotNetty.Common.Concurrency.IPromise"/> to be notified when the opening handshake is done</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.HandshakeAsync(DotNetty.Transport.Channels.IChannel,DotNetty.Codecs.Http.IHttpRequest,DotNetty.Codecs.Http.HttpHeaders)">
            <summary>
            Performs the opening handshake
            When call this method you <c>MUST NOT</c> retain the <see cref="T:DotNetty.Codecs.Http.IHttpRequest"/> which is passed in.
            </summary>
            <param name="channel">Channel</param>
            <param name="req">HTTP Request</param>
            <param name="responseHeaders">Extra headers to add to the handshake response or <code>null</code> if no extra headers should be added</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.NewHandshakeResponse(DotNetty.Codecs.Http.IFullHttpRequest,DotNetty.Codecs.Http.HttpHeaders)">
            <summary>
            Returns a new <see cref="T:DotNetty.Codecs.Http.IFullHttpResponse"/> which will be used for as response to the handshake request.
            </summary>
            <param name="req"></param>
            <param name="responseHeaders"></param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.CloseAsync(DotNetty.Transport.Channels.IChannel,DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame)">
            <summary>
            Performs the closing handshake
            </summary>
            <param name="channel">Channel</param>
            <param name="frame">Closing Frame that was received</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.SelectSubprotocol(System.String)">
            <summary>
            Selects the first matching supported sub protocol
            </summary>
            <param name="requestedSubprotocols">CSV of protocols to be supported. e.g. "chat, superchat"</param>
            <returns>First matching supported sub protocol. Null if not found.</returns>
        </member>
        <member name="P:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.SelectedSubprotocol">
            <summary>
            Returns the selected subprotocol. Null if no subprotocol has been selected.
            <para>This is only available AFTER <tt>handshake()</tt> has been called.</para>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.NewWebsocketDecoder">
            <summary>
            Returns the decoder to use after handshake is complete.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker.NewWebSocketEncoder">
            <summary>
            Returns the encoder to use after the handshake is complete.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker00">
            <summary>
            Performs server side opening and closing handshakes for web socket specification version <a
            href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-00" >draft-ietf-hybi-thewebsocketprotocol-00</a>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker00.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Constructor specifying the destination web socket location
            </summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's requirement may
            reduce denial of service attacks using long data frames.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker00.#ctor(System.String,System.String,DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig)">
            <summary>
            Constructor specifying the destination web socket location
            </summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web socket frames will be
            sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols</param>
            <param name="decoderConfig">Frames decoder configuration.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker00.NewHandshakeResponse(DotNetty.Codecs.Http.IFullHttpRequest,DotNetty.Codecs.Http.HttpHeaders)">
             <summary>
             <para>
             Handle the web socket handshake for the web socket specification <a href=
             "http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-00">HyBi version 0</a> and lower. This standard
             is really a rehash of <a href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-76" >hixie-76</a> and
             <a href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol-75" >hixie-75</a>.
             </para>
            
             <para>
             Browser request to the server:
             </para>
            
             <![CDATA[
             GET /demo HTTP/1.1
             Upgrade: WebSocket
             Connection: Upgrade
             Host: example.com
             Origin: http://example.com
             Sec-WebSocket-Protocol: chat, sample
             Sec-WebSocket-Key1: 4 @1  46546xW%0l 1 5
             Sec-WebSocket-Key2: 12998 5 Y3 1  .P00
            
             ^n:ds[4U
             ]]>
            
             <para>
             Server response:
             </para>
            
             <![CDATA[
             HTTP/1.1 101 WebSocket Protocol Handshake
             Upgrade: WebSocket
             Connection: Upgrade
             Sec-WebSocket-Origin: http://example.com
             Sec-WebSocket-Location: ws://example.com/demo
             Sec-WebSocket-Protocol: sample
            
             8jKS'y:G*Co,Wxa-
             ]]>
             </summary>
             <param name="req"></param>
             <param name="headers"></param>
             <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker00.CloseAsync(DotNetty.Transport.Channels.IChannel,DotNetty.Codecs.Http.WebSockets.CloseWebSocketFrame)">
            <summary>
            Echo back the closing frame
            </summary>
            <param name="channel">Channel</param>
            <param name="frame">Web Socket frame that was received</param>
            <returns></returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker00.NewWebsocketDecoder">
            <inheritdoc/>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker00.NewWebSocketEncoder">
            <inheritdoc/>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker07">
            <summary>
            Performs server side opening and closing handshakes for web socket specification version <a
            href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10" >draft-ietf-hybi-thewebsocketprotocol-10</a>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker07.#ctor(System.String,System.String,System.Boolean,System.Int32)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker07.#ctor(System.String,System.String,System.Boolean,System.Int32,System.Boolean)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker07.#ctor(System.String,System.String,DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl"></param>
            <param name="subprotocols"></param>
            <param name="decoderConfig">Frames decoder configuration.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker07.NewHandshakeResponse(DotNetty.Codecs.Http.IFullHttpRequest,DotNetty.Codecs.Http.HttpHeaders)">
             <summary>
             Handle the web socket handshake for the web socket specification <a href=
             "http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-07">HyBi version 7</a>.
            
             <para>
             Browser request to the server:
             </para>
            
             <![CDATA[
             GET /chat HTTP/1.1
             Host: server.example.com
             Upgrade: websocket
             Connection: Upgrade
             Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
             Sec-WebSocket-Origin: http://example.com
             Sec-WebSocket-Protocol: chat, superchat
             Sec-WebSocket-Version: 7
             ]]>
            
             <para>
             Server response:
             </para>
            
             <![CDATA[
             HTTP/1.1 101 Switching Protocols
             Upgrade: websocket
             Connection: Upgrade
             Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
             Sec-WebSocket-Protocol: chat
             ]]>
             </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker08">
            <summary>
            Performs server side opening and closing handshakes for web socket specification version <a
            href="http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-10" >draft-ietf-hybi-thewebsocketprotocol-10</a>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker08.#ctor(System.String,System.String,System.Boolean,System.Int32)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker08.#ctor(System.String,System.String,System.Boolean,System.Int32,System.Boolean)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker08.#ctor(System.String,System.String,DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols</param>
            <param name="decoderConfig">Frames decoder configuration.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker08.NewHandshakeResponse(DotNetty.Codecs.Http.IFullHttpRequest,DotNetty.Codecs.Http.HttpHeaders)">
             <summary>
             Handle the web socket handshake for the web socket specification <a href=
             "http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-08">HyBi version 8 to 10</a>. Version 8, 9 and
             10 share the same wire protocol.
            
             <para>
             Browser request to the server:
             </para>
            
             <![CDATA[
             GET /chat HTTP/1.1
             Host: server.example.com
             Upgrade: websocket
             Connection: Upgrade
             Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
             Sec-WebSocket-Origin: http://example.com
             Sec-WebSocket-Protocol: chat, superchat
             Sec-WebSocket-Version: 8
             ]]>
            
             <para>
             Server response:
             </para>
            
             <![CDATA[
             HTTP/1.1 101 Switching Protocols
             Upgrade: websocket
             Connection: Upgrade
             Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
             Sec-WebSocket-Protocol: chat
             ]]>
             </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker08.NewWebsocketDecoder">
            <inheritdoc />
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker08.NewWebSocketEncoder">
            <inheritdoc />
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker13">
            <summary>
            Performs server side opening and closing handshakes for <a href="https://netty.io/s/rfc6455">RFC 6455</a>
            (originally web socket specification <a href="https://netty.io/s/ws-17">draft-ietf-hybi-thewebsocketprotocol-17</a>).
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker13.#ctor(System.String,System.String,System.Boolean,System.Int32)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web
            socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker13.#ctor(System.String,System.String,System.Boolean,System.Int32,System.Boolean)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web
            socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker13.#ctor(System.String,System.String,DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketURL">URL for web socket communications. e.g "ws://myhost.com/mypath". Subsequent web
            socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols</param>
            <param name="decoderConfig">Frames decoder configuration.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker13.NewHandshakeResponse(DotNetty.Codecs.Http.IFullHttpRequest,DotNetty.Codecs.Http.HttpHeaders)">
             <summary>
             Handle the web socket handshake for the web socket specification <a href=
             "http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17">HyBi versions 13-17</a>. Versions 13-17
             share the same wire protocol.
            
             <para>
             Browser request to the server:
             </para>
            
             <![CDATA[
             GET /chat HTTP/1.1
             Host: server.example.com
             Upgrade: websocket
             Connection: Upgrade
             Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
             Origin: http://example.com
             Sec-WebSocket-Protocol: chat, superchat
             Sec-WebSocket-Version: 13
             ]]>
            
             <para>
             Server response:
             </para>
            
             <![CDATA[
             HTTP/1.1 101 Switching Protocols
             Upgrade: websocket
             Connection: Upgrade
             Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
             Sec-WebSocket-Protocol: chat
             ]]>
             </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshakerFactory">
            <summary>
            Auto-detects the version of the Web Socket protocol in use and creates a new proper
            <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshaker"/>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshakerFactory.#ctor(System.String,System.String,System.Boolean)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols. Null if sub protocols not supported.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshakerFactory.#ctor(System.String,System.String,System.Boolean,System.Int32)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols. Null if sub protocols not supported.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshakerFactory.#ctor(System.String,System.String,System.Boolean,System.Int32,System.Boolean)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols. Null if sub protocols not supported.</param>
            <param name="allowExtensions">Allow extensions to be used in the reserved bits of the web socket frame</param>
            <param name="maxFramePayloadLength">Maximum allowable frame payload length. Setting this value to your application's
            requirement may reduce denial of service attacks using long data frames.</param>
            <param name="allowMaskMismatch">When set to true, frames which are not masked properly according to the standard will still be
            accepted.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshakerFactory.#ctor(System.String,System.String,DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig)">
            <summary>Constructor specifying the destination web socket location</summary>
            <param name="webSocketUrl">URL for web socket communications. e.g "ws://myhost.com/mypath".
            Subsequent web socket frames will be sent to this URL.</param>
            <param name="subprotocols">CSV of supported protocols. Null if sub protocols not supported.</param>
            <param name="decoderConfig">Frames decoder options.</param>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshakerFactory.NewHandshaker(DotNetty.Codecs.Http.IHttpRequest)">
            <summary>Instances a new handshaker</summary>
            <param name="req"></param>
            <returns>A new WebSocketServerHandshaker for the requested web socket version. Null if web
            socket version is not supported.</returns>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerHandshakerFactory.SendUnsupportedVersionResponse(DotNetty.Transport.Channels.IChannel)">
            <summary>
            Return that we need cannot not support the web socket version
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig">
            <summary>
            WebSocket server configuration.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.WebsocketPath">
            <summary>
            URI path component to handle websocket upgrade requests on.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Subprotocols">
            <summary>
            CSV of supported protocols
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.CheckStartsWith">
            <summary>
            <c>true</c> to handle all requests, where URI path component starts from
            <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.WebsocketPath"/>, <c>false</c> for exact match (default).
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.HandshakeTimeoutMillis">
            <summary>
            Handshake timeout in mills, when handshake timeout, will trigger user
            event <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HandshakeTimeout"/>
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.ForceCloseTimeoutMillis">
            <summary>
            Close the connection if it was not closed by the client after timeout specified
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.HandleCloseFrames">
            <summary>
            <c>true</c> if close frames should not be forwarded and just close the channel
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.SendCloseFrame">
            <summary>
            Close frame to send, when close frame was not send manually. Or <c>null</c> to disable proper close.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.DropPongFrames">
            <summary>
            <c>true</c> if pong frames should not be forwarded
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.DecoderConfig">
            <summary>
            Frames decoder configuration.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.WebsocketPath(System.String)">
            <summary>
            URI path component to handle websocket upgrade requests on.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.Subprotocols(System.String)">
            <summary>
            CSV of supported protocols
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.CheckStartsWith(System.Boolean)">
            <summary>
            <c>true</c> to handle all requests, where URI path component starts from
            <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.WebsocketPath"/>, <c>false</c> for exact match (default).
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.HandshakeTimeoutMillis(System.Int64)">
            <summary>
            Handshake timeout in mills, when handshake timeout, will trigger user
            event <see cref="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HandshakeTimeout"/>
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.ForceCloseTimeoutMillis(System.Int64)">
            <summary>
            Close the connection if it was not closed by the client after timeout specified
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.HandleCloseFrames(System.Boolean)">
            <summary>
            <c>true</c> if close frames should not be forwarded and just close the channel
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.SendCloseFrame(DotNetty.Codecs.Http.WebSockets.WebSocketCloseStatus)">
            <summary>
            Close frame to send, when close frame was not send manually. Or <c>null</c> to disable proper close.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.DropPongFrames(System.Boolean)">
            <summary>
            <c>true</c> if pong frames should not be forwarded
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.DecoderConfig(DotNetty.Codecs.Http.WebSockets.WebSocketDecoderConfig)">
            <summary>
            Frames decoder configuration.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.MaxFramePayloadLength(System.Int32)">
            <summary>
            Maximum length of a frame's payload. Setting this to an appropriate value for you application
            helps check for denial of services attacks.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.ExpectMaskedFrames(System.Boolean)">
            <summary>
            Web socket servers must set this to true processed incoming masked payload. Client implementations
            must set this to false.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.AllowMaskMismatch(System.Boolean)">
            <summary>
            Allows to loosen the masking requirement on received frames. When this is set to false then also
            frames which are not masked properly according to the standard will still be accepted.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.AllowExtensions(System.Boolean)">
            <summary>
            Flag to allow reserved extension bits to be used or not
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.CloseOnProtocolViolation(System.Boolean)">
            <summary>
            Flag to send close frame immediately on any protocol violation.ion.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.WithUTF8Validator(System.Boolean)">
            <summary>
            Allows you to avoid adding of Utf8FrameValidator to the pipeline on the
            <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolHandler"/> creation. This is useful (less overhead)
            when you use only BinaryWebSocketFrame within your web socket connection.
            </summary>
        </member>
        <member name="M:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolConfig.Builder.Build">
            <summary>
            Build unmodifiable server protocol configuration.
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolHandler">
             <summary>
             This handler does all the heavy lifting for you to run a websocket server.
            
             It takes care of websocket handshaking as well as processing of control frames (Close, Ping, Pong). Text and Binary
             data frames are passed to the next handler in the pipeline (implemented by you) for processing.
            
             See <tt>io.netty.example.http.websocketx.html5.WebSocketServer</tt> for usage.
            
             The implementation of this handler assumes that you just want to run  a websocket server and not process other types
             HTTP requests (like GET and POST). If you wish to support both HTTP requests and websockets in the one server, refer
             to the <tt>io.netty.example.http.websocketx.server.WebSocketServer</tt> example.
            
             To know once a handshake was done you can intercept the
             <see cref="M:DotNetty.Transport.Channels.IChannelHandler.UserEventTriggered(DotNetty.Transport.Channels.IChannelHandlerContext,System.Object)"/> and check if the event was instance
             of <see cref="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolHandler.HandshakeComplete"/>, the event will contain extra information about the handshake such as the request and
             selected subprotocol.
             </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolHandler.ServerHandshakeStateEvent">
            <summary>
            Events that are fired to notify about handshake status
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HandshakeComplete">
            <summary>
            The Handshake was completed successfully and the channel was upgraded to websockets.
            </summary>
        </member>
        <member name="F:DotNetty.Codecs.Http.WebSockets.WebSocketServerProtocolHandler.ServerHandshakeStateEvent.HandshakeTimeout">
            <summary>
            The Handshake was timed out
            </summary>
        </member>
        <member name="T:DotNetty.Codecs.Http.WebSockets.WebSocketUtil">
            <summary>
            A utility class mainly for use by web sockets
            </summary>
        </member>
        <member name="T:WebSocketSharp.Rsv">
            <summary>
            Indicates whether each RSV (RSV1, RSV2, and RSV3) of a WebSocket frame is non-zero.
            </summary>
            <remarks>
            The values of this enumeration are defined in
            <see href="http://tools.ietf.org/html/rfc6455#section-5.2">Section 5.2</see> of RFC 6455.
            </remarks>
        </member>
        <member name="F:WebSocketSharp.Rsv.Off">
            <summary>
            Equivalent to numeric value 0. Indicates zero.
            </summary>
        </member>
        <member name="F:WebSocketSharp.Rsv.On">
            <summary>
            Equivalent to numeric value 1. Indicates non-zero.
            </summary>
        </member>
    </members>
</doc>
